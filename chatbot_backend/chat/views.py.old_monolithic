from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.decorators import api_view, authentication_classes, permission_classes
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.parsers import MultiPartParser, FormParser
from django.http import HttpResponse, Http404
from chat.serializers import UserSerializer, VideoChatSessionSerializer, VideoChatMessageSerializer, VideoAnalysisCacheSerializer
from chat.models import VideoChatSession, VideoChatMessage, VideoAnalysisCache, Video
from .services.video_analysis_service import video_analysis_service
from .enhanced_video_chat_handler import get_video_chat_handler
from .person_search_handler import handle_person_search_command
from .advanced_search_view import InterVideoSearchView, IntraVideoSearchView, TemporalAnalysisView
from .advanced_command_handler import handle_inter_video_search_command, handle_intra_video_search_command, handle_temporal_analysis_command
from .ai_response_generator import ai_response_generator
from .evaluation_metrics import evaluation_metrics
from .conversation_memory import conversation_memory
from .integrated_chat_service import integrated_chat_service
from .llm_cache_manager import llm_cache_manager, conversation_context_manager
from django.utils import timezone
import threading
import openai
import anthropic
from groq import Groq
import ollama
import anthropic
import google.generativeai as genai
import os
import sys
import io
import PyPDF2
from PIL import Image
import pytesseract
import hashlib
import time
# import cv2  # NumPy í˜¸í™˜ì„± ë¬¸ì œë¡œ ì¡°ê±´ë¶€ import
# import numpy as np  # NumPy í˜¸í™˜ì„± ë¬¸ì œë¡œ ì¡°ê±´ë¶€ import
from pdf2image import convert_from_bytes
import base64
import tempfile
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
import requests
import uuid
import hmac
import hashlib
from django.contrib.auth import get_user_model
from chat.models import User, SocialAccount
from django.conf import settings

# ë¶„ë¦¬ëœ ëª¨ë“ˆë“¤ import
from .config.ai_config import (
    KOREAN_LANGUAGE_INSTRUCTION,
    OPENAI_MODEL_COMPLETION_LIMITS,
    DEFAULT_OPENAI_COMPLETION_LIMIT
)
from .utils.error_handlers import get_user_friendly_error_message
from .utils.file_utils import (
    extract_text_from_pdf,
    extract_text_from_pdf_ocr,
    extract_text_from_image,
    process_uploaded_file,
    summarize_content,
    analyze_image_with_ollama
)
from .utils.ai_utils import (
    enforce_korean_instruction,
    get_openai_completion_limit,
    generate_optimal_response_with_ollama,
    generate_optimal_response
)
from .utils.chatbot import ChatBot, chatbots
from .services.optimal_response import (
    collect_multi_llm_responses,
    detect_conflicts_in_responses,
    judge_and_generate_optimal_response,
    call_judge_model,
    parse_judge_response,
    create_fallback_result,
    format_optimal_response,
    classify_question_type,
    detect_question_type_from_content
)
from .services.video_search import (
    quick_web_verify,
    search_wikipedia,
    extract_search_terms_from_question,
    search_wikipedia_api,
    get_wikipedia_full_text,
    search_google_simple
)
import json
import ast
import logging
import re
from datetime import datetime, timedelta

# ë¡œê±° ì„¤ì •
logger = logging.getLogger(__name__)

# ì¸ì½”ë”© ë¬¸ì œ í•´ê²°ì„ ìœ„í•œ ì„¤ì •
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')


class ChatView(APIView):
    def post(self, request, bot_name):
        try:
            data = request.data
            user_message = data.get('message')
            uploaded_file = request.FILES.get('file')
            
            if not user_message and not uploaded_file:
                return Response({'error': 'No message or file provided'}, status=status.HTTP_400_BAD_REQUEST)
            
            chatbot = chatbots.get(bot_name)
            if not chatbot:
                print(f"âŒ Invalid bot name: {bot_name}")
                print(f"   ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸: {list(chatbots.keys())[:10]}...")
                return Response({'error': 'Invalid bot name'}, status=status.HTTP_400_BAD_REQUEST)

            # íŒŒì¼ì´ ì—…ë¡œë“œëœ ê²½ìš° ì²˜ë¦¬
            if uploaded_file:
                try:
                    print(f"íŒŒì¼ ì—…ë¡œë“œ ê°ì§€: {uploaded_file.name}")
                    
                    # íŒŒì¼ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ ë˜ëŠ” ì´ë¯¸ì§€ íŒŒì¼ ì‹ë³„
                    extracted_content = process_uploaded_file(uploaded_file)
                    print(f"ğŸ“„ ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ê¸¸ì´: {len(extracted_content)}ì")
                    print(f"ğŸ“„ ì¶”ì¶œëœ ë‚´ìš© ë¯¸ë¦¬ë³´ê¸° (ì²˜ìŒ 200ì): {extracted_content[:200]}...")
                    
                    # Ollamaë¡œ ë¶„ì„ (ì´ë¯¸ì§€ëŠ” ì§ì ‘, í…ìŠ¤íŠ¸ëŠ” ì „ì²´ ë‚´ìš© ì „ë‹¬)
                    print("Ollamaë¥¼ ì‚¬ìš©í•˜ì—¬ íŒŒì¼ ë¶„ì„ ì¤‘...")
                    
                    # ì„ì‹œ íŒŒì¼ ì €ì¥
                    temp_file_path = None
                    if extracted_content.startswith("IMAGE_FILE:"):
                        # ì´ë¯¸ì§€ íŒŒì¼ì„ ì„ì‹œë¡œ ì €ì¥
                        import tempfile
                        import shutil
                        temp_dir = tempfile.mkdtemp()
                        temp_file_path = os.path.join(temp_dir, uploaded_file.name)
                        with open(temp_file_path, 'wb') as temp_file:
                            uploaded_file.seek(0)  # íŒŒì¼ í¬ì¸í„° ë¦¬ì…‹
                            for chunk in uploaded_file.chunks():
                                temp_file.write(chunk)
                        print(f"ì´ë¯¸ì§€ íŒŒì¼ ì„ì‹œ ì €ì¥: {temp_file_path}")
                    
                    # ì‚¬ìš©ìê°€ ì§ˆë¬¸ì„ ì…ë ¥í•œ ê²½ìš°: ì „ì²´ ë‚´ìš© ì „ë‹¬ (ìš”ì•½í•˜ì§€ ì•ŠìŒ)
                    # ì§ˆë¬¸ì´ ì—†ìœ¼ë©´ ìš”ì•½ ëª¨ë“œ ì‚¬ìš©
                    use_full_content = bool(user_message and user_message.strip())
                    
                    if use_full_content:
                        print(f"ğŸ“‹ ì „ì²´ ë‚´ìš© ëª¨ë“œ: ì¶”ì¶œëœ í…ìŠ¤íŠ¸({len(extracted_content)}ì)ë¥¼ ê·¸ëŒ€ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.")
                    else:
                        print(f"ğŸ“ ìš”ì•½ ëª¨ë“œ: Ollamaë¡œ ìš”ì•½í•©ë‹ˆë‹¤.")
                    
                    analyzed_content = summarize_content(
                        extracted_content, 
                        file_path=temp_file_path,
                        full_content=use_full_content
                    )
                    
                    print(f"ğŸ“Š ìµœì¢… ë¶„ì„ ë‚´ìš© ê¸¸ì´: {len(analyzed_content)}ì")
                    
                    # ì‚¬ìš©ì ë©”ì‹œì§€ì™€ íŒŒì¼ ë¶„ì„ ê²°ê³¼ë¥¼ ê²°í•©
                    if user_message and user_message.strip():
                        # ì‚¬ìš©ìê°€ ì§ˆë¬¸ì„ ì…ë ¥í•œ ê²½ìš° - ì „ì²´ ë‚´ìš© ì „ë‹¬
                        print(f"ğŸ“ ì‚¬ìš©ì ì§ˆë¬¸ê³¼ íŒŒì¼ í•¨ê»˜ ì²˜ë¦¬: {user_message}")
                        if uploaded_file.name.lower().endswith('.pdf'):
                            final_message = f"""ë‹¤ìŒì€ ì—…ë¡œë“œëœ PDF ë¬¸ì„œì˜ ì „ì²´ ë‚´ìš©ì…ë‹ˆë‹¤:

{analyzed_content}

---
ì‚¬ìš©ì ì§ˆë¬¸: {user_message}

ìœ„ PDF ë¬¸ì„œì˜ ì „ì²´ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì˜ ì§ˆë¬¸ì— ì •í™•í•˜ê³  ìì„¸í•˜ê²Œ í•œêµ­ì–´ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”.
ë¬¸ì„œì— ì—°ìŠµ ë¬¸ì œê°€ í¬í•¨ë˜ì–´ ìˆë‹¤ë©´, ê·¸ ì—°ìŠµ ë¬¸ì œë¥¼ ì°¾ì•„ì„œ í’€ì–´ì£¼ì„¸ìš”.
ë¬¸ì„œì˜ ëª¨ë“  ë‚´ìš©ì„ ì£¼ì˜ ê¹Šê²Œ ì½ê³ , ê´€ë ¨ëœ ì •ë³´ë¥¼ ëª¨ë‘ í¬í•¨í•˜ì—¬ ë‹µë³€í•´ì£¼ì„¸ìš”."""
                        else:
                            # ì´ë¯¸ì§€ì¸ ê²½ìš° (Ollamaê°€ ì˜ì–´ë¡œ ë¶„ì„í•œ ê²°ê³¼ë¥¼ ì—¬ëŸ¬ LLMì´ í•œêµ­ì–´ë¡œ ë‹µë³€)
                            final_message = f"""ë‹¤ìŒì€ ì—…ë¡œë“œëœ ì´ë¯¸ì§€ë¥¼ Ollamaë¡œ ë¶„ì„í•œ ê²°ê³¼ì…ë‹ˆë‹¤ (ì˜ì–´):

{analyzed_content}

ì‚¬ìš©ì ì§ˆë¬¸: {user_message}

ìœ„ ì˜ì–´ë¡œ ì‘ì„±ëœ ì´ë¯¸ì§€ ë¶„ì„ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì˜ ì§ˆë¬¸ì— í•œêµ­ì–´ë¡œ ìì„¸íˆ ë‹µë³€í•´ì£¼ì„¸ìš”. ì´ë¯¸ì§€ ë¶„ì„ ê²°ê³¼ì˜ ë‚´ìš©ì„ ì¶©ì‹¤íˆ ë°˜ì˜í•˜ì—¬ ë‹µë³€í•´ì£¼ì„¸ìš”."""
                    else:
                        # ì‚¬ìš©ì ë©”ì‹œì§€ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ë¶„ì„ ìš”ì²­
                        if uploaded_file.name.lower().endswith('.pdf'):
                            final_message = f"ë‹¤ìŒ ë¬¸ì„œ ë‚´ìš©ì„ í•œêµ­ì–´ë¡œ ìš”ì•½í•´ì£¼ì„¸ìš”:\n\n{analyzed_content}"
                        else:
                            final_message = f"""ë‹¤ìŒì€ ì—…ë¡œë“œëœ ì´ë¯¸ì§€ë¥¼ Ollamaë¡œ ë¶„ì„í•œ ê²°ê³¼ì…ë‹ˆë‹¤ (ì˜ì–´):

{analyzed_content}

ìœ„ ì˜ì–´ë¡œ ì‘ì„±ëœ ì´ë¯¸ì§€ ë¶„ì„ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì´ ì´ë¯¸ì§€ì— ëŒ€í•´ í•œêµ­ì–´ë¡œ ìì„¸í•˜ê³  ìì—°ìŠ¤ëŸ½ê²Œ ì„¤ëª…í•´ì£¼ì„¸ìš”. ì´ë¯¸ì§€ ë¶„ì„ ê²°ê³¼ì˜ ë‚´ìš©ì„ ì¶©ì‹¤íˆ ë°˜ì˜í•˜ì—¬ ë‹µë³€í•´ì£¼ì„¸ìš”."""
                    print("ë¶„ì„ ì™„ë£Œ")
                except Exception as e:
                    print(f"íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜: {str(e)}")
                    final_message = f"íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"
            else:
                final_message = user_message

            # optimal ëª¨ë¸ì¸ ê²½ìš° íŠ¹ë³„ ì²˜ë¦¬
            if bot_name == 'optimal':
                # ì‚¬ìš©ì ì„ íƒ ì‹¬íŒ ëª¨ë¸ (ê¸°ë³¸ê°’: GPT-4o - ë¹ ë¥¸ ì†ë„ + ìš°ìˆ˜í•œ ì„±ëŠ¥)
                judge_model = request.data.get('judge_model', 'GPT-4o')
                
                # ì‚¬ìš©ìê°€ ì„ íƒí•œ LLM ëª¨ë¸ë“¤ (í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ì „ë‹¬)
                selected_models = request.data.get('selected_models', None)
                
                # FormDataë¡œ ì „ë‹¬ëœ ê²½ìš° JSON íŒŒì‹±
                if isinstance(selected_models, str):
                    try:
                        import json
                        selected_models = json.loads(selected_models)
                        print(f"ğŸ“‹ JSON íŒŒì‹±ëœ selected_models: {selected_models}")
                    except Exception as e:
                        print(f"âš ï¸ selected_models JSON íŒŒì‹± ì‹¤íŒ¨: {e}")
                        selected_models = None
                
                # selected_modelsê°€ ë¹ˆ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° ì²˜ë¦¬
                if selected_models is not None and len(selected_models) == 0:
                    print(f"âš ï¸ selected_modelsê°€ ë¹ˆ ë¦¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤. ê¸°ë³¸ ëª¨ë¸ ì‚¬ìš©")
                    selected_models = None
                
                print(f"ğŸ¯ ì‚¬ìš©ì ì„ íƒ ëª¨ë¸ë“¤: {selected_models}")
                print(f"ğŸ¯ ì‹¬íŒ ëª¨ë¸: {judge_model}")
                print(f"ğŸ“ ì²˜ë¦¬í•  ë©”ì‹œì§€ ê¸¸ì´: {len(final_message)}ì")
                
                # 1-4ë‹¨ê³„: ì„ íƒëœ LLM ë³‘ë ¬ ì§ˆì˜ â†’ ì‹¬íŒ ëª¨ë¸ ê²€ì¦ â†’ ìµœì  ë‹µë³€ ìƒì„±
                response = None
                try:
                    print(f"ğŸš€ ìµœì  ë‹µë³€ ìƒì„± ì‹œì‘...")
                    print(f"ğŸ“ ì‚¬ìš©ì ë©”ì‹œì§€: {final_message[:200]}...")
                    print(f"ğŸ¯ ì„ íƒëœ ëª¨ë¸: {selected_models}")
                    print(f"âš–ï¸ ì‹¬íŒ ëª¨ë¸: {judge_model}")
                    
                    # ì§ˆë¬¸ ìœ í˜• ê°ì§€
                    has_image = uploaded_file and not uploaded_file.name.lower().endswith('.pdf')
                    has_document = uploaded_file and uploaded_file.name.lower().endswith('.pdf')
                    
                    question_type = None
                    if has_image:
                        question_type = 'image'
                    elif has_document:
                        question_type = 'document'
                    else:
                        question_type = detect_question_type_from_content(final_message)
                    
                    final_result = collect_multi_llm_responses(final_message, judge_model, selected_models, question_type=question_type)
                    print(f"âœ… ìµœì  ë‹µë³€ ìƒì„± ì™„ë£Œ: {type(final_result)}")
                    print(f"âœ… ìµœì  ë‹µë³€ ê²°ê³¼ í‚¤: {list(final_result.keys()) if isinstance(final_result, dict) else 'N/A'}")
                    
                    # ìµœì  ë‹µë³€ ë‚´ìš© í™•ì¸
                    optimal_answer = final_result.get("ìµœì ì˜_ë‹µë³€", "")
                    if not optimal_answer:
                        # optimal_answerê°€ ì—†ìœ¼ë©´ ë‹¤ë¥¸ í‚¤ í™•ì¸
                        optimal_answer = final_result.get("optimal_answer", "")
                    print(f"ğŸ“„ ìµœì  ë‹µë³€ ë‚´ìš© ê¸¸ì´: {len(optimal_answer) if optimal_answer else 0}ì")
                    print(f"ğŸ“„ ìµœì  ë‹µë³€ ë¯¸ë¦¬ë³´ê¸°: {optimal_answer[:300] if optimal_answer else 'None'}...")
                    
                    # optimal_answerê°€ ìˆìœ¼ë©´ ìµœì ì˜_ë‹µë³€ìœ¼ë¡œ ë³€í™˜
                    if optimal_answer and not final_result.get("ìµœì ì˜_ë‹µë³€"):
                        final_result["ìµœì ì˜_ë‹µë³€"] = optimal_answer
                    
                    # ê²°ê³¼ í¬ë§·íŒ…
                    response = format_optimal_response(final_result)
                    print(f"âœ… ê²°ê³¼ í¬ë§·íŒ… ì™„ë£Œ: {len(response) if response else 0}ì")
                    print(f"âœ… í¬ë§·íŒ…ëœ ì‘ë‹µ ë¯¸ë¦¬ë³´ê¸°: {response[:500] if response else 'None'}...")
                    
                    # ëŒ€í™” ë§¥ë½ì— ì¶”ê°€
                    session_id = request.data.get('user_id', 'default_user')
                    conversation_context_manager.add_conversation(
                        session_id=session_id,
                        user_message=final_message,
                        ai_responses=final_result.get('llm_ê²€ì¦_ê²°ê³¼', {}),
                        optimal_response=final_result.get('ìµœì ì˜_ë‹µë³€', '')
                    )
                    
                    # responseê°€ Noneì´ë©´ ì˜¤ë¥˜ ë©”ì‹œì§€ ë°˜í™˜
                    if not response:
                        print(f"âŒ responseê°€ Noneì…ë‹ˆë‹¤!")
                        response = "ìµœì  ë‹µë³€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì„œë²„ ë¡œê·¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
                    
                    print(f"ğŸ“¤ ìµœì¢… ì‘ë‹µ ë°˜í™˜ (ê¸¸ì´: {len(response) if response else 0}ì)")
                    print(f"ğŸ“¤ ìµœì¢… ì‘ë‹µ ë¯¸ë¦¬ë³´ê¸°: {response[:500] if response else 'None'}...")
                    
                    # í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ë¶„ì„ ë°ì´í„°ë¥¼ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ JSON ë°ì´í„°ë„ í•¨ê»˜ ì „ì†¡
                    return Response({
                        'response': response,
                        'analysisData': final_result.get('llm_ê²€ì¦_ê²°ê³¼', {}),
                        'rationale': final_result.get('ë¶„ì„_ê·¼ê±°', '')
                    })
                    
                except Exception as e:
                    import traceback
                    error_trace = traceback.format_exc()
                    print(f"âŒ ìµœì  ë‹µë³€ ìƒì„± ì‹¤íŒ¨: {e}")
                    print(f"âŒ ìƒì„¸ ì˜¤ë¥˜:\n{error_trace}")
                    # í´ë°±: ì‚¬ìš©ì ì¹œí™”ì ì¸ ì˜¤ë¥˜ ë©”ì‹œì§€ ë°˜í™˜
                    friendly_error = get_user_friendly_error_message(e)
                    return Response({'response': friendly_error})
            
            # optimal ëª¨ë¸ì´ ì•„ë‹Œ ê²½ìš°
            # ë¹„ìš© ì ˆì•½: íŒŒì¼ ë¶„ì„ ì‹œ ê°„ì†Œí™”ëœ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©
            has_image = uploaded_file and not uploaded_file.name.lower().endswith('.pdf')
            has_document = uploaded_file and uploaded_file.name.lower().endswith('.pdf')
            
            # ì§ˆë¬¸ ìœ í˜• ìë™ ê°ì§€
            question_type = None
            if has_image:
                question_type = 'image'
            elif has_document:
                question_type = 'document'
            else:
                question_type = detect_question_type_from_content(final_message)
            
            if uploaded_file and 'íŒŒì¼ ë‚´ìš©ì„ ë¶„ì„í•´' in final_message:
                # ì´ë¯¸ Ollamaë¡œ ë¶„ì„ëœ ë‚´ìš©ì´ë¯€ë¡œ ê°„ë‹¨í•œ ì‘ë‹µ ìš”ì²­
                simplified_message = f"ë‹¤ìŒ ë¶„ì„ ë‚´ìš©ì— ëŒ€í•´ ê°„ë‹¨í•œ ì˜ê²¬ì„ ì œì‹œí•´ì£¼ì„¸ìš”:\n\n{final_message.split('ë‹¤ìŒ íŒŒì¼ ë‚´ìš©ì„ ë¶„ì„í•´ì£¼ì„¸ìš”:')[1] if 'ë‹¤ìŒ íŒŒì¼ ë‚´ìš©ì„ ë¶„ì„í•´ì£¼ì„¸ìš”:' in final_message else final_message}"
                response = chatbot.chat(simplified_message, has_image=has_image, question_type=question_type)
            else:
                response = chatbot.chat(final_message, has_image=has_image, question_type=question_type)
            
            return Response({'response': response})
        except Exception as e:
            import traceback
            traceback.print_exc()
            # ì‚¬ìš©ì ì¹œí™”ì ì¸ ì˜¤ë¥˜ ë©”ì‹œì§€ ë°˜í™˜
            friendly_error = get_user_friendly_error_message(e)
            return Response({'error': friendly_error}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

def generate_unique_username(email, name=None):
    """ì´ë©”ì¼ ê¸°ë°˜ìœ¼ë¡œ ê³ ìœ í•œ ì‚¬ìš©ìëª… ìƒì„±"""
    base_username = email.split('@')[0]
    username = base_username
    counter = 1
    
    while User.objects.filter(username=username).exists():
        username = f"{base_username}_{counter}"
        counter += 1
    
    return username

@api_view(['GET'])
@authentication_classes([TokenAuthentication])
@permission_classes([AllowAny])
def google_callback(request):
    try:
        # ì•¡ì„¸ìŠ¤ í† í° ì¶”ì¶œ
        auth_header = request.headers.get('Authorization', '')
        if not auth_header.startswith('Bearer '):
            return Response(
                {'error': 'ì˜ëª»ëœ ì¸ì¦ í—¤ë”'}, 
                status=status.HTTP_401_UNAUTHORIZED
            )
        
        access_token = auth_header.split(' ')[1]

        # Google APIë¡œ ì‚¬ìš©ì ì •ë³´ ìš”ì²­
        user_info_response = requests.get(
            'https://www.googleapis.com/oauth2/v3/userinfo',
            headers={'Authorization': f'Bearer {access_token}'}
        )

        if user_info_response.status_code != 200:
            return Response(
                {'error': 'Googleì—ì„œ ì‚¬ìš©ì ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        user_info = user_info_response.json()
        email = user_info.get('email')
        name = user_info.get('name')
        
        if not email:
            return Response(
                {'error': 'ì´ë©”ì¼ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            # ê¸°ì¡´ ì‚¬ìš©ì ê²€ìƒ‰
            user = User.objects.get(email=email)
            # ê¸°ì¡´ ì‚¬ìš©ìì˜ ì´ë¦„ì´ ì—†ìœ¼ë©´ ì—…ë°ì´íŠ¸
            if name and (not user.first_name and not user.last_name):
                if ' ' in name:
                    first_name, last_name = name.split(' ', 1)
                    user.first_name = first_name
                    user.last_name = last_name
                else:
                    user.first_name = name
                user.save()
        except User.DoesNotExist:
            # ìƒˆë¡œìš´ ì‚¬ìš©ì ìƒì„±
            username = generate_unique_username(email, name)
            user = User.objects.create(
                username=username,
                email=email,
                is_active=True
            )
            
            # ì´ë¦„ ì„¤ì •
            if name:
                if ' ' in name:
                    first_name, last_name = name.split(' ', 1)
                    user.first_name = first_name
                    user.last_name = last_name
                else:
                    user.first_name = name
            
            # ê¸°ë³¸ ë¹„ë°€ë²ˆí˜¸ ì„¤ì • (ì„ íƒì )
            random_password = uuid.uuid4().hex
            user.set_password(random_password)
            user.save()

        # ì†Œì…œ ê³„ì • ì •ë³´ ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸
        social_account, created = SocialAccount.objects.get_or_create(
            email=email,
            provider='google',
            defaults={'user': user}
        )

        if not created and social_account.user != user:
            social_account.user = user
            social_account.save()

        # ì‚¬ìš©ì ì •ë³´ ì§ë ¬í™”
        serializer = UserSerializer(user)
        
        return Response({
            'message': 'êµ¬ê¸€ ë¡œê·¸ì¸ ì„±ê³µ',
            'user': serializer.data
        })
        
    except Exception as e:
        return Response(
            {'error': str(e)}, 
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([AllowAny])
def kakao_callback(request):
    """ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸ ì½œë°±"""
    try:
        data = request.data
        access_token = data.get('access_token')
        
        if not access_token:
            return Response(
                {'error': 'ì•¡ì„¸ìŠ¤ í† í°ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # ì¹´ì¹´ì˜¤ APIë¡œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        user_info_response = requests.get(
            'https://kapi.kakao.com/v2/user/me',
            headers={'Authorization': f'Bearer {access_token}'}
        )
        
        if user_info_response.status_code != 200:
            return Response(
                {'error': 'ì¹´ì¹´ì˜¤ì—ì„œ ì‚¬ìš©ì ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        user_info = user_info_response.json()
        kakao_account = user_info.get('kakao_account', {})
        profile = kakao_account.get('profile', {})
        
        email = kakao_account.get('email')
        name = profile.get('nickname')
        
        if not email:
            return Response(
                {'error': 'ì´ë©”ì¼ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # ê¸°ì¡´ ì‚¬ìš©ì ê²€ìƒ‰
            user = User.objects.get(email=email)
            # ê¸°ì¡´ ì‚¬ìš©ìì˜ ì´ë¦„ì´ ì—†ìœ¼ë©´ ì—…ë°ì´íŠ¸
            if name and (not user.first_name and not user.last_name):
                user.first_name = name
                user.save()
        except User.DoesNotExist:
            # ìƒˆë¡œìš´ ì‚¬ìš©ì ìƒì„±
            username = generate_unique_username(email, name)
            user = User.objects.create(
                username=username,
                email=email,
                is_active=True
            )
            
            # ì´ë¦„ ì„¤ì •
            if name:
                user.first_name = name
            
            # ê¸°ë³¸ ë¹„ë°€ë²ˆí˜¸ ì„¤ì • (ì„ íƒì )
            random_password = uuid.uuid4().hex
            user.set_password(random_password)
            user.save()
        
        # ì†Œì…œ ê³„ì • ì •ë³´ ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸
        social_account, created = SocialAccount.objects.get_or_create(
            email=email,
            provider='kakao',
            defaults={'user': user}
        )
        
        if not created and social_account.user != user:
            social_account.user = user
            social_account.save()
        
        serializer = UserSerializer(user)
        return Response({
            'message': 'ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸ ì„±ê³µ',
            'user': serializer.data
        })
        
    except Exception as e:
        return Response(
            {'error': str(e)}, 
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@authentication_classes([TokenAuthentication])
@permission_classes([AllowAny])
def naver_callback(request):
    """ë„¤ì´ë²„ ë¡œê·¸ì¸ ì½œë°±"""
    try:
        data = request.data
        access_token = data.get('access_token')
        code = data.get('code')
        state = data.get('state')
        client_id_override = data.get('client_id')
        client_secret_override = data.get('client_secret')
        redirect_uri_override = data.get('redirect_uri')
        
        if not access_token:
            if not code:
                return Response(
                    {'error': 'access_token ë˜ëŠ” codeê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            client_id = client_id_override or os.getenv('NAVER_CLIENT_ID') or getattr(settings, 'NAVER_CLIENT_ID', '')
            client_secret = client_secret_override or os.getenv('NAVER_CLIENT_SECRET') or getattr(settings, 'NAVER_CLIENT_SECRET', '')
            redirect_uri = redirect_uri_override or os.getenv('NAVER_REDIRECT_URI') or getattr(settings, 'NAVER_REDIRECT_URI', '')
            
            if not client_id or not client_secret:
                return Response(
                    {'error': 'ë„¤ì´ë²„ í´ë¼ì´ì–¸íŠ¸ ì„¤ì •ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤'},
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )
            
            token_response = requests.post(
                'https://nid.naver.com/oauth2.0/token',
                headers={'Content-Type': 'application/x-www-form-urlencoded'},
                data={
                    'grant_type': 'authorization_code',
                    'client_id': client_id,
                    'client_secret': client_secret,
                    'redirect_uri': redirect_uri,
                    'code': code,
                    'state': state or '',
                }
            )
            
            token_data = token_response.json()
            if token_response.status_code != 200 or not token_data.get('access_token'):
                return Response(
                    {
                        'error': 'ë„¤ì´ë²„ í† í° êµí™˜ ì‹¤íŒ¨',
                        'detail': token_data
                    },
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            access_token = token_data.get('access_token')
        
        if not access_token:
            return Response(
                {'error': 'ì•¡ì„¸ìŠ¤ í† í°ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # ë„¤ì´ë²„ APIë¡œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        user_info_response = requests.get(
            'https://openapi.naver.com/v1/nid/me',
            headers={'Authorization': f'Bearer {access_token}'}
        )
        
        if user_info_response.status_code != 200:
            return Response(
                {'error': 'ë„¤ì´ë²„ì—ì„œ ì‚¬ìš©ì ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        user_info = user_info_response.json()
        response_data = user_info.get('response', {})
        
        email = response_data.get('email')
        name = response_data.get('name')
        nickname = response_data.get('nickname')
        
        if not email:
            return Response(
                {'error': 'ì´ë©”ì¼ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # ì´ë¦„ì´ ì—†ìœ¼ë©´ ë‹‰ë„¤ì„ ì‚¬ìš©
        display_name = name or nickname
        
        try:
            # ê¸°ì¡´ ì‚¬ìš©ì ê²€ìƒ‰
            user = User.objects.get(email=email)
            # ê¸°ì¡´ ì‚¬ìš©ìì˜ ì´ë¦„ì´ ì—†ìœ¼ë©´ ì—…ë°ì´íŠ¸
            if display_name and (not user.first_name and not user.last_name):
                user.first_name = display_name
                user.save()
        except User.DoesNotExist:
            # ìƒˆë¡œìš´ ì‚¬ìš©ì ìƒì„±
            username = generate_unique_username(email, display_name)
            user = User.objects.create(
                username=username,
                email=email,
                is_active=True
            )
            
            # ì´ë¦„ ì„¤ì •
            if display_name:
                user.first_name = display_name
            
            # ê¸°ë³¸ ë¹„ë°€ë²ˆí˜¸ ì„¤ì • (ì„ íƒì )
            random_password = uuid.uuid4().hex
            user.set_password(random_password)
            user.save()
        
        # ì†Œì…œ ê³„ì • ì •ë³´ ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸
        social_account, created = SocialAccount.objects.get_or_create(
            email=email,
            provider='naver',
            defaults={'user': user}
        )
        
        if not created and social_account.user != user:
            social_account.user = user
            social_account.save()
        
        serializer = UserSerializer(user)
        return Response({
            'message': 'ë„¤ì´ë²„ ë¡œê·¸ì¸ ì„±ê³µ',
            'user': serializer.data
        })
        
    except Exception as e:
        return Response(
            {'error': str(e)}, 
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

class VideoUploadView(APIView):
    """ì˜ìƒ ì—…ë¡œë“œ ë·° - ë…ë¦½ì ì¸ ì˜ìƒ ì²˜ë¦¬"""
    permission_classes = [AllowAny]  # ì„ì‹œë¡œ AllowAnyë¡œ ë³€ê²½
    parser_classes = (MultiPartParser, FormParser)
    
    def post(self, request):
        try:
            import os
            import uuid
            import time
            from django.core.files.storage import default_storage
            from django.conf import settings
            
            # ì—…ë¡œë“œëœ íŒŒì¼ í™•ì¸ (backend_videochat ë°©ì‹)
            if 'video' not in request.FILES:
                return Response({
                    'error': 'ë¹„ë””ì˜¤ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            video_file = request.FILES['video']
            
            # íŒŒì¼ í™•ì¥ì ê²€ì¦ (backend_videochat ë°©ì‹)
            if not video_file.name.lower().endswith(('.mp4', '.avi', '.mov', '.mkv', '.webm')):
                return Response({
                    'error': 'ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. MP4, AVI, MOV, MKV, WEBM í˜•ì‹ë§Œ ì§€ì›ë©ë‹ˆë‹¤.'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # íŒŒì¼ í¬ê¸° ê²€ì¦ (50MB ì œí•œ)
            max_size = 50 * 1024 * 1024  # 50MB
            if video_file.size > max_size:
                return Response({
                    'error': f'íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. ìµœëŒ€ 50MBê¹Œì§€ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤. (í˜„ì¬: {video_file.size / (1024*1024):.1f}MB)'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # íŒŒì¼ëª… ê¸¸ì´ ê²€ì¦
            if len(video_file.name) > 200:
                return Response({
                    'error': 'íŒŒì¼ëª…ì´ ë„ˆë¬´ ê¹ë‹ˆë‹¤. 200ì ì´í•˜ë¡œ ì œí•œë©ë‹ˆë‹¤.'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # ê³ ìœ í•œ íŒŒì¼ëª… ìƒì„± (backend_videochat ë°©ì‹)
            timestamp = int(time.time())
            filename = f"upload_{timestamp}_{video_file.name}"
            
            # íŒŒì¼ ì €ì¥ (backend_videochat ë°©ì‹)
            from django.core.files.base import ContentFile
            file_path = default_storage.save(
                f'uploads/{filename}',
                ContentFile(video_file.read())
            )
            full_path = os.path.join(settings.MEDIA_ROOT, file_path)
            
            # íŒŒì¼ ì €ì¥ ê²€ì¦
            if not os.path.exists(full_path):
                return Response({
                    'error': 'íŒŒì¼ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            
            # íŒŒì¼ í¬ê¸° ì¬ê²€ì¦ (ì‹¤ì œ ì €ì¥ëœ íŒŒì¼)
            actual_size = os.path.getsize(full_path)
            if actual_size == 0:
                return Response({
                    'error': 'ë¹ˆ íŒŒì¼ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤. ìœ íš¨í•œ ì˜ìƒ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Create Video model instance (backend_videochat ë°©ì‹)
            video = Video.objects.create(
                filename=filename,
                original_name=video_file.name,
                file_path=file_path,
                file_size=video_file.size,
                file=file_path,  # file í•„ë“œë„ ì €ì¥
                analysis_status='pending'
            )
            
            # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì˜ìƒ ë¶„ì„ ì‹œì‘
            def analyze_video_background():
                try:
                    print(f"ğŸ¬ ë°±ê·¸ë¼ìš´ë“œ ì˜ìƒ ë¶„ì„ ì‹œì‘: {video.id}")
                    
                    # íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ ì¬í™•ì¸
                    if not os.path.exists(full_path):
                        print(f"âŒ ì˜ìƒ íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ: {full_path}")
                        video.analysis_status = 'failed'
                        video.analysis_message = 'ì˜ìƒ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
                        video.save()
                        return
                    
                    analysis_result = video_analysis_service.analyze_video(file_path, video.id)
                    if analysis_result and analysis_result is not True:
                        # ë¶„ì„ ê²°ê³¼ê°€ ë”•ì…”ë„ˆë¦¬ì¸ ê²½ìš° (ì˜¤ë¥˜ ì •ë³´ í¬í•¨)
                        if isinstance(analysis_result, dict) and not analysis_result.get('success', True):
                            print(f"âŒ ì˜ìƒ ë¶„ì„ ì‹¤íŒ¨: {video.id} - {analysis_result.get('error_message', 'Unknown error')}")
                            video.analysis_status = 'failed'
                            video.analysis_message = analysis_result.get('error_message', 'ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
                        else:
                            print(f"âœ… ì˜ìƒ ë¶„ì„ ì™„ë£Œ: {video.id}")
                            video.analysis_status = 'completed'
                            video.is_analyzed = True
                    else:
                        print(f"âŒ ì˜ìƒ ë¶„ì„ ì‹¤íŒ¨: {video.id}")
                        video.analysis_status = 'failed'
                        video.analysis_message = 'ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
                    
                    video.save()
                except Exception as e:
                    print(f"âŒ ë°±ê·¸ë¼ìš´ë“œ ë¶„ì„ ì˜¤ë¥˜: {e}")
                    video.analysis_status = 'failed'
                    video.analysis_message = f'ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}'
                    video.save()
            
            # ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ë¶„ì„ ì‹¤í–‰
            analysis_thread = threading.Thread(target=analyze_video_background)
            analysis_thread.daemon = True
            analysis_thread.start()
            
            return Response({
                'success': True,
                'video_id': video.id,
                'filename': filename,
                'message': f'ë¹„ë””ì˜¤ "{video_file.name}"ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.'
            })
                
        except Exception as e:
            return Response({
                'error': f'ì˜ìƒ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class VideoListView(APIView):
    """ë¹„ë””ì˜¤ ëª©ë¡ ì¡°íšŒ - backend_videochat ë°©ì‹"""
    permission_classes = [AllowAny]
    
    def get(self, request):
        try:
            videos = Video.objects.all()
            video_list = []
            
            for video in videos:
                # ìƒíƒœ ë™ê¸°í™” ìˆ˜í–‰ (íŒŒì¼ê³¼ DB ìƒíƒœ ì¼ì¹˜ í™•ì¸)
                video_analysis_service.sync_video_status_with_files(video.id)
                
                # ë™ê¸°í™” í›„ ìµœì‹  ìƒíƒœë¡œ ë‹¤ì‹œ ê°€ì ¸ì˜¤ê¸°
                video.refresh_from_db()
                
                # ë¶„ì„ ìƒíƒœ ê²°ì • (ë” ì •í™•í•œ íŒë‹¨)
                actual_analysis_status = video.analysis_status
                if video.analysis_status == 'completed' and not video.analysis_json_path:
                    actual_analysis_status = 'failed'
                    print(f"âš ï¸ ì˜ìƒ {video.id}: analysis_statusëŠ” completedì´ì§€ë§Œ analysis_json_pathê°€ ì—†ìŒ")
                
                video_data = {
                    'id': video.id,
                    'filename': video.filename,
                    'original_name': video.original_name,
                    'duration': video.duration,
                    'is_analyzed': video.is_analyzed,
                    'analysis_status': actual_analysis_status,  # ì‹¤ì œ ìƒíƒœ ì‚¬ìš©
                    'uploaded_at': video.uploaded_at,
                    'file_size': video.file_size,
                    'analysis_progress': video.analysis_progress,  # ì§„í–‰ë¥  ì •ë³´ ì¶”ê°€
                    'analysis_message': video.analysis_message or ''  # ë¶„ì„ ë©”ì‹œì§€ ì¶”ê°€
                }
                video_list.append(video_data)
            
            return Response({
                'videos': video_list,
                'count': len(video_list)
            })
            
        except Exception as e:
            return Response({
                'error': f'ë¹„ë””ì˜¤ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class VideoDeleteView(APIView):
    """ì˜ìƒ ì‚­ì œ API"""
    permission_classes = [AllowAny]
    
    def delete(self, request, video_id):
        try:
            video = Video.objects.get(id=video_id)
            
            # íŒŒì¼ ì‚­ì œ
            if video.file and os.path.exists(video.file.path):
                try:
                    os.remove(video.file.path)
                    logger.info(f"âœ… ì˜ìƒ íŒŒì¼ ì‚­ì œ: {video.file.path}")
                except Exception as e:
                    logger.warning(f"ì˜ìƒ íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨: {e}")
            
            # ë¶„ì„ ê²°ê³¼ íŒŒì¼ ì‚­ì œ
            if video.analysis_json_path:
                json_path = os.path.join(settings.MEDIA_ROOT, video.analysis_json_path)
                if os.path.exists(json_path):
                    try:
                        os.remove(json_path)
                        logger.info(f"âœ… ë¶„ì„ ê²°ê³¼ íŒŒì¼ ì‚­ì œ: {json_path}")
                    except Exception as e:
                        logger.warning(f"ë¶„ì„ ê²°ê³¼ íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨: {e}")
            
            # í”„ë ˆì„ ì´ë¯¸ì§€ íŒŒì¼ ì‚­ì œ
            if video.frame_images_path:
                frame_paths = video.frame_images_path.split(',')
                for path in frame_paths:
                    full_path = os.path.join(settings.MEDIA_ROOT, path.strip())
                    if os.path.exists(full_path):
                        try:
                            os.remove(full_path)
                        except Exception as e:
                            logger.warning(f"í”„ë ˆì„ ì´ë¯¸ì§€ ì‚­ì œ ì‹¤íŒ¨: {e}")
            
            # DBì—ì„œ ì‚­ì œ
            video_name = video.original_name
            video.delete()
            
            logger.info(f"âœ… ì˜ìƒ ì‚­ì œ ì™„ë£Œ: {video_name} (ID: {video_id})")
            
            return Response({
                'message': f'ì˜ìƒ "{video_name}"ì´(ê°€) ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.',
                'video_id': video_id
            })
            
        except Video.DoesNotExist:
            return Response({
                'error': 'ì˜ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
            }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"âŒ ì˜ìƒ ì‚­ì œ ì˜¤ë¥˜: {e}")
            return Response({
                'error': f'ì˜ìƒ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class VideoRenameView(APIView):
    """ì˜ìƒ ì´ë¦„ ë³€ê²½ API"""
    permission_classes = [AllowAny]
    
    def post(self, request, video_id):
        try:
            video = Video.objects.get(id=video_id)
            new_name = request.data.get('original_name', '').strip()
            
            if not new_name:
                return Response({
                    'error': 'ìƒˆ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            old_name = video.original_name
            video.original_name = new_name
            video.save()
            
            logger.info(f"âœ… ì˜ìƒ ì´ë¦„ ë³€ê²½: {old_name} â†’ {new_name} (ID: {video_id})")
            
            return Response({
                'message': f'ì˜ìƒ ì´ë¦„ì´ "{new_name}"(ìœ¼)ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.',
                'video_id': video_id,
                'new_name': new_name
            })
            
        except Video.DoesNotExist:
            return Response({
                'error': 'ì˜ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
            }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"âŒ ì˜ìƒ ì´ë¦„ ë³€ê²½ ì˜¤ë¥˜: {e}")
            return Response({
                'error': f'ì˜ìƒ ì´ë¦„ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class VideoAnalysisView(APIView):
    """ì˜ìƒ ë¶„ì„ ìƒíƒœ í™•ì¸ ë° ì‹œì‘ - backend_videochat ë°©ì‹"""
    permission_classes = [AllowAny]
    
    def get(self, request, video_id):
        try:
            video = Video.objects.get(id=video_id)
            
            # ìƒíƒœ ë™ê¸°í™” ìˆ˜í–‰ (íŒŒì¼ê³¼ DB ìƒíƒœ ì¼ì¹˜ í™•ì¸)
            video_analysis_service.sync_video_status_with_files(video_id)
            
            # ë™ê¸°í™” í›„ ìµœì‹  ìƒíƒœë¡œ ë‹¤ì‹œ ê°€ì ¸ì˜¤ê¸°
            video.refresh_from_db()
            
            # ì§„í–‰ë¥  ì •ë³´ ì¶”ì¶œ
            progress_info = {
                'analysis_progress': video.analysis_progress,
                'analysis_message': video.analysis_message or ''
            }
            
            # ë¶„ì„ ìƒíƒœ ê²°ì • (ë” ì •í™•í•œ íŒë‹¨)
            actual_analysis_status = video.analysis_status
            if video.analysis_status == 'completed' and not video.analysis_json_path:
                actual_analysis_status = 'failed'
                print(f"âš ï¸ ì˜ìƒ {video_id}: analysis_statusëŠ” completedì´ì§€ë§Œ analysis_json_pathê°€ ì—†ìŒ")
            
            return Response({
                'video_id': video.id,
                'filename': video.filename,
                'original_name': video.original_name,
                'analysis_status': actual_analysis_status,  # ì‹¤ì œ ìƒíƒœ ì‚¬ìš©
                'is_analyzed': video.is_analyzed,
                'duration': video.duration,
                'progress': progress_info,  # í”„ë¡ íŠ¸ì—”ë“œê°€ ê¸°ëŒ€í•˜ëŠ” êµ¬ì¡°ë¡œ ë³€ê²½
                'uploaded_at': video.uploaded_at,
                'file_size': video.file_size,
                'analysis_json_path': video.analysis_json_path,
                'frame_images_path': video.frame_images_path
            })
        except Video.DoesNotExist:
            return Response({
                'error': 'ì˜ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤'
            }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({
                'error': f'ì˜ìƒ ë¶„ì„ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def post(self, request, video_id):
        """ì˜ìƒ ë¶„ì„ ì‹œì‘"""
        try:
            video = Video.objects.get(id=video_id)
            
            # ì´ë¯¸ ë¶„ì„ ì¤‘ì´ê±°ë‚˜ ì™„ë£Œëœ ê²½ìš°
            if video.analysis_status == 'pending':
                return Response({
                    'message': 'ì´ë¯¸ ë¶„ì„ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.',
                    'status': 'pending'
                })
            elif video.analysis_status == 'completed':
                return Response({
                    'message': 'ì´ë¯¸ ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.',
                    'status': 'completed'
                })
            
            # ë¶„ì„ ìƒíƒœë¥¼ pendingìœ¼ë¡œ ë³€ê²½
            video.analysis_status = 'pending'
            video.save()
            
            # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì˜ìƒ ë¶„ì„ ì‹œì‘
            def analyze_video_background():
                try:
                    print(f"ğŸ¬ ë°±ê·¸ë¼ìš´ë“œ ì˜ìƒ ë¶„ì„ ì‹œì‘: {video.id}")
                    analysis_result = video_analysis_service.analyze_video(video.file_path, video.id)
                    if analysis_result:
                        print(f"âœ… ì˜ìƒ ë¶„ì„ ì™„ë£Œ: {video.id}")
                        # Video ëª¨ë¸ ì—…ë°ì´íŠ¸
                        video.analysis_status = 'completed'
                        video.is_analyzed = True
                        video.save()
                    else:
                        print(f"âŒ ì˜ìƒ ë¶„ì„ ì‹¤íŒ¨: {video.id}")
                        video.analysis_status = 'failed'
                        video.save()
                except Exception as e:
                    print(f"âŒ ë°±ê·¸ë¼ìš´ë“œ ë¶„ì„ ì˜¤ë¥˜: {e}")
                    video.analysis_status = 'failed'
                    video.save()
            
            # ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ë¶„ì„ ì‹¤í–‰
            analysis_thread = threading.Thread(target=analyze_video_background)
            analysis_thread.daemon = True
            analysis_thread.start()
            
            return Response({
                'message': 'ì˜ìƒ ë¶„ì„ì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤.',
                'status': 'pending'
            })
            
        except Video.DoesNotExist:
            return Response({
                'error': 'ì˜ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤'
            }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({
                'error': f'ì˜ìƒ ë¶„ì„ ì‹œì‘ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class VideoChatView(APIView):
    """ì˜ìƒ ì±„íŒ… ë·° - ë‹¤ì¤‘ AI ì‘ë‹µ ë° í†µí•©"""
    permission_classes = [AllowAny]  # ì„ì‹œë¡œ AllowAnyë¡œ ë³€ê²½
    
    def get(self, request, video_id=None):
        """ì±„íŒ… ì„¸ì…˜ ëª©ë¡ ì¡°íšŒ"""
        try:
            print(f"ğŸ” VideoChatView GET ìš”ì²­ - video_id: {video_id}")
            
            # ì‚¬ìš©ì ì •ë³´ ì²˜ë¦¬ (ì¸ì¦ë˜ì§€ ì•Šì€ ê²½ìš° ê¸°ë³¸ ì‚¬ìš©ì ì‚¬ìš©)
            user = None
            if hasattr(request, 'user') and request.user.is_authenticated:
                user = request.user
            else:
                # ê¸°ë³¸ ì‚¬ìš©ì ìƒì„± ë˜ëŠ” ê°€ì ¸ì˜¤ê¸°
                from chat.models import User
                user, created = User.objects.get_or_create(
                    username='anonymous',
                    defaults={'email': 'anonymous@example.com'}
                )
                print(f"âœ… ê¸°ë³¸ ì‚¬ìš©ì ìƒì„±/ê°€ì ¸ì˜¤ê¸°: {user.username}")
            
            if video_id:
                # íŠ¹ì • ì˜ìƒì˜ ì±„íŒ… ì„¸ì…˜ ì¡°íšŒ
                sessions = VideoChatSession.objects.filter(
                    user=user, 
                    video_id=video_id,
                    is_active=True
                ).order_by('-created_at')
            else:
                # ì‚¬ìš©ìì˜ ëª¨ë“  ì±„íŒ… ì„¸ì…˜ ì¡°íšŒ
                sessions = VideoChatSession.objects.filter(
                    user=user,
                    is_active=True
                ).order_by('-created_at')
            
            serializer = VideoChatSessionSerializer(sessions, many=True)
            return Response({
                'sessions': serializer.data,
                'total_count': sessions.count()
            })
            
        except Exception as e:
            return Response({
                'error': f'ì±„íŒ… ì„¸ì…˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def post(self, request, video_id):
        """ì˜ìƒ ì±„íŒ… ë©”ì‹œì§€ ì „ì†¡"""
        try:
            print(f"ğŸ” VideoChatView POST ìš”ì²­ - video_id: {video_id}")
            # Django WSGIRequestì—ì„œ JSON ë°ì´í„° íŒŒì‹±
            import json
            if hasattr(request, 'data'):
                message = request.data.get('message')
            else:
                body = request.body.decode('utf-8')
                data = json.loads(body)
                message = data.get('message')
            print(f"ğŸ“ ë©”ì‹œì§€: {message}")
            
            if not message:
                return Response({
                    'error': 'ë©”ì‹œì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # ì˜ìƒ ë¶„ì„ ìƒíƒœ í™•ì¸ (Video ëª¨ë¸ì—ì„œ ì§ì ‘ í™•ì¸)
            try:
                video = Video.objects.get(id=video_id)
                if video.analysis_status == 'pending':
                    return Response({
                        'error': 'ì˜ìƒ ë¶„ì„ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
                        'status': 'analyzing'
                    }, status=status.HTTP_202_ACCEPTED)
                elif video.analysis_status == 'failed':
                    return Response({
                        'error': 'ì˜ìƒ ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì˜ìƒì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.',
                        'status': 'failed'
                    }, status=status.HTTP_400_BAD_REQUEST)
            except Video.DoesNotExist:
                return Response({
                    'error': 'ì˜ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤'
                }, status=status.HTTP_404_NOT_FOUND)
            
            # ì‚¬ìš©ì ì •ë³´ ì²˜ë¦¬ (ì¸ì¦ë˜ì§€ ì•Šì€ ê²½ìš° ê¸°ë³¸ ì‚¬ìš©ì ì‚¬ìš©)
            user = request.user if request.user.is_authenticated else None
            if not user:
                # ê¸°ë³¸ ì‚¬ìš©ì ìƒì„± ë˜ëŠ” ê°€ì ¸ì˜¤ê¸°
                from chat.models import User
                user, created = User.objects.get_or_create(
                    username='anonymous',
                    defaults={'email': 'anonymous@example.com'}
                )
            
            # ì±„íŒ… ì„¸ì…˜ ê°€ì ¸ì˜¤ê¸° ë˜ëŠ” ìƒì„±
            session, created = VideoChatSession.objects.get_or_create(
                user=user,
                video_id=video_id,
                is_active=True,
                defaults={
                    'video_title': f"Video {video_id}",
                    'video_analysis_data': {}
                }
            )
            
            # ì‚¬ìš©ì ë©”ì‹œì§€ ì €ì¥
            user_message = VideoChatMessage.objects.create(
                session=session,
                message_type='user',
                content=message
            )
            
            # ğŸ¯ ê°œì„ ëœ í•¸ë“¤ëŸ¬ ì‚¬ìš©
            print(f"ğŸ” ê°œì„ ëœ ì˜ìƒ ì±„íŒ… í•¸ë“¤ëŸ¬ ì‚¬ìš©: '{message}'")
            handler = get_video_chat_handler(video_id, video)
            chat_result = handler.process_message(message)
            
            # AI ê°œë³„ ì‘ë‹µ ì €ì¥
            individual_messages = []
            if chat_result.get('individual_responses'):
                for ai_name, ai_content in chat_result['individual_responses'].items():
                    ai_message = VideoChatMessage.objects.create(
                        session=session,
                        message_type='ai',
                        content=ai_content,
                        ai_model=ai_name,
                        parent_message=user_message
                    )
                    individual_messages.append(ai_message)
            
            # í†µí•© ì‘ë‹µ ì €ì¥
            optimal_response = chat_result.get('answer', '')
            optimal_message = None
            if optimal_response:
                optimal_message = VideoChatMessage.objects.create(
                    session=session,
                    message_type='ai_optimal',
                    content=optimal_response,
                    ai_model='optimal',
                    parent_message=user_message
                )
            
            # í”„ë ˆì„ ì •ë³´ êµ¬ì„±
            relevant_frames = []
            if chat_result.get('frames'):
                # ë©”íƒ€ DBì—ì„œ ì „ì²´ í”„ë ˆì„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì˜ìƒë³„ ë™ì  ê²½ë¡œ)
                meta_db_filename = f"{video.original_name or video.filename}-meta_db.json"
                meta_db_path = os.path.join(settings.MEDIA_ROOT, meta_db_filename)
                all_frames = []
                if os.path.exists(meta_db_path):
                    try:
                        with open(meta_db_path, 'r', encoding='utf-8') as f:
                            meta_data = json.load(f)
                            all_frames = meta_data.get('frame', [])
                    except Exception as meta_error:
                        logger.warning(f"ë©”íƒ€ DB ë¡œë“œ ì‹¤íŒ¨({meta_db_path}): {meta_error}")
                else:
                    logger.warning(f"ë©”íƒ€ DB íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {meta_db_path}")
                
                for idx, frame in enumerate(chat_result['frames']):
                    meta_frame = None
                    if all_frames:
                        # timestamp ê¸°ì¤€ìœ¼ë¡œ ë©”íƒ€ í”„ë ˆì„ ì°¾ê¸°
                        for candidate in all_frames:
                            if abs(candidate.get('timestamp', 0) - frame.get('timestamp', 0)) < 0.1:
                                meta_frame = candidate
                                break
                    
                    # ì´ë¯¸ì§€ ê²½ë¡œì™€ ID ê²°ì •
                    image_id = frame.get('image_id')
                    if not image_id and meta_frame:
                        image_id = meta_frame.get('image_id')
                    if not image_id:
                        image_id = idx + 1
                    
                    frame_image_path = frame.get('frame_image_path')
                    if not frame_image_path and meta_frame:
                        frame_image_path = meta_frame.get('frame_image_path')
                    if not frame_image_path:
                        frame_image_path = f"images/video{video_id}_frame{image_id}.jpg"
                    frame_image_path = frame_image_path.lstrip('/')
                    
                    raw_objects = frame.get('objects', []) or []
                    persons = frame.get('persons')
                    if persons is None:
                        persons = [obj for obj in raw_objects if obj.get('class') == 'person']
                    
                    other_objects = frame.get('detected_other_objects')
                    if other_objects is None:
                        other_objects = [obj for obj in raw_objects if obj.get('class') != 'person']
                    
                    frame_info = {
                        'image_id': image_id,
                        'timestamp': frame.get('timestamp', 0),
                        'image_url': f"/media/{frame_image_path}",
                        'caption': frame.get('caption', ''),
                        'relevance_score': frame.get('match_score', 1.0),
                        'persons': persons[:3] if persons else [],
                        'objects': other_objects,
                        'scene_attributes': {
                            'scene_type': 'unknown',
                            'lighting': 'unknown',
                            'activity_level': 'unknown'
                        }
                    }
                    relevant_frames.append(frame_info)
            
            # ì‘ë‹µ ë°ì´í„° êµ¬ì„± (í”„ë¡ íŠ¸ì—”ë“œ í˜•ì‹ì— ë§ì¶¤)
            response_data = {
                'session_id': str(session.id),
                'user_message': {
                    'id': str(user_message.id),
                    'content': message,
                    'created_at': user_message.created_at.isoformat()
                },
                'ai_responses': {
                    'individual': [
                        {
                            'id': str(msg.id),
                            'model': msg.ai_model,
                            'content': msg.content,
                            'created_at': msg.created_at.isoformat()
                        } for msg in individual_messages
                    ],
                    'optimal': {
                        'id': str(optimal_message.id) if optimal_message else None,
                        'model': 'optimal',
                        'content': optimal_response,
                        'created_at': optimal_message.created_at.isoformat() if optimal_message else None
                    } if optimal_response else None
                },
                'relevant_frames': relevant_frames,
                'is_video_related': chat_result.get('is_video_related', True)
            }
            
            print(f"âœ… ì‘ë‹µ ìƒì„± ì™„ë£Œ:")
            print(f"   - ê°œë³„ AI: {len(individual_messages)}ê°œ")
            print(f"   - í†µí•© ì‘ë‹µ: {'ìˆìŒ' if optimal_response else 'ì—†ìŒ'}")
            print(f"   - ê´€ë ¨ í”„ë ˆì„: {len(relevant_frames)}ê°œ")
            
            return Response(response_data)
            
        except Exception as e:
            import traceback
            print(f"âŒ ì˜¤ë¥˜ ë°œìƒ: {e}")
            print(f"âŒ ìƒì„¸: {traceback.format_exc()}")
            return Response({
                'error': f'ì±„íŒ… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            
            # ì˜ìƒ ë¶„ì„ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (Video ëª¨ë¸ì—ì„œ ì§ì ‘)
            analysis_data = {
                'original_name': video.original_name,
                'file_size': video.file_size,
                'uploaded_at': video.uploaded_at.isoformat(),
                'analysis_status': video.analysis_status,
                'duration': video.duration,
                'is_analyzed': video.is_analyzed
            }
            
            # JSON ë¶„ì„ ê²°ê³¼ ë¡œë“œ (ê¸°ì¡´ + TeletoVision_AI ìŠ¤íƒ€ì¼)
            analysis_json_data = None
            teleto_vision_data = {}
            
            # 1. ê¸°ì¡´ ë¶„ì„ JSON ë¡œë“œ
            if video.analysis_json_path:
                try:
                    json_path = os.path.join(settings.MEDIA_ROOT, video.analysis_json_path)
                    print(f"ğŸ” ê¸°ì¡´ JSON íŒŒì¼ ê²½ë¡œ: {json_path}")
                    print(f"ğŸ” íŒŒì¼ ì¡´ì¬ ì—¬ë¶€: {os.path.exists(json_path)}")
                    
                    with open(json_path, 'r', encoding='utf-8') as f:
                        analysis_json_data = json.load(f)
                    print(f"âœ… ê¸°ì¡´ JSON ë¶„ì„ ê²°ê³¼ ë¡œë“œ ì„±ê³µ: {json_path}")
                    print(f"ğŸ“Š ê¸°ì¡´ JSON ë°ì´í„° í‚¤: {list(analysis_json_data.keys())}")
                    if 'frame_results' in analysis_json_data:
                        print(f"ğŸ“Š frame_results ê°œìˆ˜: {len(analysis_json_data['frame_results'])}")
                        if analysis_json_data['frame_results']:
                            print(f"ğŸ“Š ì²« ë²ˆì§¸ í”„ë ˆì„: {analysis_json_data['frame_results'][0]}")
                except Exception as e:
                    print(f"âŒ ê¸°ì¡´ JSON ë¶„ì„ ê²°ê³¼ ë¡œë“œ ì‹¤íŒ¨: {e}")
                    import traceback
                    print(f"âŒ ìƒì„¸ ì˜¤ë¥˜: {traceback.format_exc()}")
            else:
                print("âŒ analysis_json_pathê°€ ì—†ìŠµë‹ˆë‹¤.")
            
            # 2. TeletoVision_AI ìŠ¤íƒ€ì¼ JSON ë¡œë“œ
            try:
                video_name = video.original_name or video.filename
                detection_db_path = os.path.join(settings.MEDIA_ROOT, f"{video_name}-detection_db.json")
                meta_db_path = os.path.join(settings.MEDIA_ROOT, f"{video_name}-meta_db.json")
                
                print(f"ğŸ” TeletoVision detection_db ê²½ë¡œ: {detection_db_path}")
                print(f"ğŸ” TeletoVision meta_db ê²½ë¡œ: {meta_db_path}")
                
                # detection_db.json ë¡œë“œ
                if os.path.exists(detection_db_path):
                    with open(detection_db_path, 'r', encoding='utf-8') as f:
                        teleto_vision_data['detection_db'] = json.load(f)
                    print(f"âœ… TeletoVision detection_db ë¡œë“œ ì„±ê³µ: {len(teleto_vision_data['detection_db'])}ê°œ í”„ë ˆì„")
                else:
                    print(f"âŒ TeletoVision detection_db íŒŒì¼ ì—†ìŒ: {detection_db_path}")
                
                # meta_db.json ë¡œë“œ
                if os.path.exists(meta_db_path):
                    with open(meta_db_path, 'r', encoding='utf-8') as f:
                        teleto_vision_data['meta_db'] = json.load(f)
                    print(f"âœ… TeletoVision meta_db ë¡œë“œ ì„±ê³µ: {len(teleto_vision_data['meta_db'].get('frame', []))}ê°œ í”„ë ˆì„")
                    if teleto_vision_data['meta_db'].get('frame'):
                        first_frame = teleto_vision_data['meta_db']['frame'][0]
                        print(f"ğŸ“Š ì²« ë²ˆì§¸ meta í”„ë ˆì„ í‚¤: {list(first_frame.keys())}")
                else:
                    print(f"âŒ TeletoVision meta_db íŒŒì¼ ì—†ìŒ: {meta_db_path}")
                    
            except Exception as e:
                print(f"âŒ TeletoVision JSON ë¡œë“œ ì‹¤íŒ¨: {e}")
                import traceback
                print(f"âŒ ìƒì„¸ ì˜¤ë¥˜: {traceback.format_exc()}")
                teleto_vision_data = {}
                print(f"âŒ video.analysis_json_path: {video.analysis_json_path}")
            
            # í”„ë ˆì„ ê²€ìƒ‰ ë° ì´ë¯¸ì§€ URL ìƒì„±
            print(f"ğŸ” í”„ë ˆì„ ê²€ìƒ‰ ì‹œì‘ - analysis_json_data: {analysis_json_data is not None}")
            if analysis_json_data:
                print(f"ğŸ“Š frame_results ì¡´ì¬: {'frame_results' in analysis_json_data}")
                if 'frame_results' in analysis_json_data:
                    print(f"ğŸ“Š frame_results ê°œìˆ˜: {len(analysis_json_data['frame_results'])}")
            else:
                print("âŒ analysis_json_dataê°€ Noneì…ë‹ˆë‹¤!")
                print(f"âŒ video.analysis_json_path: {video.analysis_json_path}")
                print(f"âŒ video.analysis_status: {video.analysis_status}")
                print(f"âŒ video.is_analyzed: {video.is_analyzed}")
            
            # ëŒ€í™” ë§¥ë½ ê°€ì ¸ì˜¤ê¸°
            session_id = f"video_{video_id}_user_{user.id}"
            context_prompt = conversation_memory.generate_context_prompt(session_id, message)
            
            # í”„ë ˆì„ ê²€ìƒ‰ (ì˜ë„ ê¸°ë°˜)
            relevant_frames = self._find_relevant_frames(message, analysis_json_data, video_id)
            print(f"ğŸ” ê²€ìƒ‰ëœ í”„ë ˆì„ ìˆ˜: {len(relevant_frames)}")
            if relevant_frames:
                print(f"ğŸ“¸ ì²« ë²ˆì§¸ í”„ë ˆì„: {relevant_frames[0]}")
                print(f"ğŸ“¸ ëª¨ë“  í”„ë ˆì„ ì •ë³´:")
                for i, frame in enumerate(relevant_frames):
                    print(f"  í”„ë ˆì„ {i+1}: {frame}")
            else:
                print("âŒ ê²€ìƒ‰ëœ í”„ë ˆì„ì´ ì—†ìŠµë‹ˆë‹¤!")
                print(f"âŒ analysis_json_data keys: {list(analysis_json_data.keys()) if analysis_json_data else 'None'}")
                if analysis_json_data and 'frame_results' in analysis_json_data:
                    print(f"âŒ frame_results ê°œìˆ˜: {len(analysis_json_data['frame_results'])}")
                    if analysis_json_data['frame_results']:
                        print(f"âŒ ì²« ë²ˆì§¸ frame_result: {analysis_json_data['frame_results'][0]}")
            
            # ë‹¤ì¤‘ AI ì‘ë‹µ ìƒì„±
            ai_responses = {}
            individual_messages = []
            
            # ê¸°ë³¸ ì±„íŒ… ì‹œìŠ¤í…œê³¼ ë™ì¼í•œ AI ëª¨ë¸ ì´ˆê¸°í™”
            try:
                # ì „ì—­ chatbots ë³€ìˆ˜ ì‚¬ìš© (ì´ë¯¸ ì´ˆê¸°í™”ë˜ì–´ ìˆìŒ)
                print(f"âœ… ì‚¬ìš© ê°€ëŠ¥í•œ AI ëª¨ë¸: {list(chatbots.keys())}")
            except Exception as e:
                print(f"âš ï¸ AI ëª¨ë¸ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                # ì „ì—­ chatbots ë³€ìˆ˜ëŠ” ì´ë¯¸ ì´ˆê¸°í™”ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë®ì–´ì“°ì§€ ì•ŠìŒ
            
            # AI ëª¨ë¸ í™•ì¸
            print(f"ğŸ¤– ì‚¬ìš© ê°€ëŠ¥í•œ AI ëª¨ë¸: {list(chatbots.keys()) if chatbots else 'None'}")
            
            # AI ëª¨ë¸ì´ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ ì‘ë‹µ (í”„ë ˆì„ ì •ë³´ í¬í•¨)
            if not chatbots:
                print("âš ï¸ ì‚¬ìš© ê°€ëŠ¥í•œ AI ëª¨ë¸ì´ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ ì‘ë‹µì„ ìƒì„±í•©ë‹ˆë‹¤.")
                
                # í”„ë ˆì„ ì •ë³´ë¥¼ í¬í•¨í•œ ë” ë‚˜ì€ ì‘ë‹µ ìƒì„±
                if relevant_frames:
                    frame_count = len(relevant_frames)
                    default_response = f"ì˜ìƒì—ì„œ '{message}'ì™€ ê´€ë ¨ëœ {frame_count}ê°œì˜ í”„ë ˆì„ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤!\n\n"
                    
                    for i, frame in enumerate(relevant_frames, 1):
                        default_response += f"ğŸ“¸ í”„ë ˆì„ {i}:\n"
                        default_response += f"   â° ì‹œê°„: {frame['timestamp']:.1f}ì´ˆ\n"
                        default_response += f"   ğŸ¯ ê´€ë ¨ë„: {frame['relevance_score']}ì \n"
                        
                        if frame['persons'] and len(frame['persons']) > 0:
                            default_response += f"   ğŸ‘¤ ì‚¬ëŒ {len(frame['persons'])}ëª… ê°ì§€\n"
                        
                        if frame['objects'] and len(frame['objects']) > 0:
                            default_response += f"   ğŸ“¦ ê°ì²´ {len(frame['objects'])}ê°œ ê°ì§€\n"
                        
                        scene_attrs = frame.get('scene_attributes', {})
                        if scene_attrs:
                            scene_type = scene_attrs.get('scene_type', 'unknown')
                            lighting = scene_attrs.get('lighting', 'unknown')
                            activity = scene_attrs.get('activity_level', 'unknown')
                            default_response += f"   ğŸï¸ ì¥ë©´: {scene_type}, ì¡°ëª…: {lighting}, í™œë™: {activity}\n"
                        
                        default_response += "\n"
                    
                    default_response += "ğŸ’¡ AI ëª¨ë¸ì´ í™œì„±í™”ë˜ë©´ ë” ìì„¸í•œ ë¶„ì„ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
                else:
                    default_response = f"ì£„ì†¡í•©ë‹ˆë‹¤. '{message}'ì™€ ê´€ë ¨ëœ í”„ë ˆì„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n"
                    default_response += "ë‹¤ë¥¸ í‚¤ì›Œë“œë¡œ ì‹œë„í•´ë³´ì„¸ìš”:\n"
                    default_response += "â€¢ ì‚¬ëŒ, ìë™ì°¨, ë™ë¬¼, ìŒì‹, ì˜·, ê±´ë¬¼, ìì—°, ë¬¼ì²´"
                
                ai_responses = {
                    'default': default_response
                }
            else:
                # ê° AI ëª¨ë¸ì— ì§ˆë¬¸ ì „ì†¡
                for bot_name, chatbot in chatbots.items():
                    if bot_name == 'optimal':
                        continue  # optimalì€ ë‚˜ì¤‘ì— ì²˜ë¦¬
                    
                    try:
                        # ìƒ‰ìƒ ê²€ìƒ‰ ëª¨ë“œ í™•ì¸
                        is_color_search = any(keyword in message.lower() for keyword in ['ë¹¨ê°„ìƒ‰', 'íŒŒë€ìƒ‰', 'ë…¸ë€ìƒ‰', 'ì´ˆë¡ìƒ‰', 'ë³´ë¼ìƒ‰', 'ë¶„í™ìƒ‰', 'ê²€ì€ìƒ‰', 'í°ìƒ‰', 'íšŒìƒ‰', 'ì£¼í™©ìƒ‰', 'ê°ˆìƒ‰', 'ì˜·'])
                        
                        # ê°„ì†Œí™”ëœ ì˜ìƒ ì •ë³´ í”„ë¡¬í”„íŠ¸ ìƒì„±
                        video_context = f"""
ì˜ìƒ: {analysis_data.get('original_name', 'Unknown')} ({analysis_data.get('file_size', 0) / (1024*1024):.1f}MB)
ë¶„ì„: {len(analysis_json_data.get('frame_results', []))}ê°œ í”„ë ˆì„, {analysis_json_data.get('video_summary', {}).get('total_detections', 0)}ê°œ ê°ì²´
í’ˆì§ˆ: {analysis_json_data.get('video_summary', {}).get('quality_assessment', {}).get('overall_score', 0):.2f}
"""
                        
                        # ê°„ì†Œí™”ëœ í”„ë ˆì„ ì •ë³´
                        frame_context = ""
                        if relevant_frames:
                            frame_context = f"\nê´€ë ¨ í”„ë ˆì„ {len(relevant_frames)}ê°œ:\n"
                            for i, frame in enumerate(relevant_frames[:2], 1):  # ìµœëŒ€ 2ê°œë§Œ
                                frame_context += f"í”„ë ˆì„ {i}: {frame['timestamp']:.1f}ì´ˆ, ì‚¬ëŒ {len(frame.get('persons', []))}ëª…\n"
                        else:
                            frame_context = "\nê´€ë ¨ í”„ë ˆì„ ì—†ìŒ\n"
                        
                        enhanced_message = f"""{video_context}{frame_context}

ì‚¬ìš©ì ì§ˆë¬¸: "{message}"

ìœ„ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì¹œê·¼í•˜ê²Œ ë‹µë³€í•´ì£¼ì„¸ìš”."""
                        
                        # ê°„ì†Œí™”ëœ AI í”„ë¡¬í”„íŠ¸
                        ai_prompt = enhanced_message
                        
                        # AIë³„ íŠ¹ì„±í™”ëœ í”„ë¡¬í”„íŠ¸ë¡œ ì‘ë‹µ ìƒì„±
                        ai_response = chatbot.chat(ai_prompt)
                        ai_responses[bot_name] = ai_response
                        
                        # ê°œë³„ AI ì‘ë‹µ ì €ì¥
                        ai_message = VideoChatMessage.objects.create(
                            session=session,
                            message_type='ai',
                            content=ai_response,
                            ai_model=bot_name,
                            parent_message=user_message
                        )
                        individual_messages.append(ai_message)
                        
                    except Exception as e:
                        print(f"AI {bot_name} ì‘ë‹µ ìƒì„± ì‹¤íŒ¨: {str(e)}")
                        continue
            
            # í†µí•© ì‘ë‹µ ìƒì„± (ê¸°ë³¸ ì±„íŒ… ì‹œìŠ¤í…œê³¼ ë™ì¼í•œ ë°©ì‹)
            optimal_response = ""
            if ai_responses and len(ai_responses) > 1:
                try:
                    # ê¸°ë³¸ ì±„íŒ… ì‹œìŠ¤í…œì˜ generate_optimal_response ì‚¬ìš©
                    optimal_response = generate_optimal_response(ai_responses, message, os.getenv('OPENAI_API_KEY'))
                    
                    # í”„ë ˆì„ ì •ë³´ ì¶”ê°€ (ë” ìì„¸í•œ ì •ë³´ í¬í•¨)
                    if relevant_frames:
                        frame_summary = f"\n\nğŸ“¸ ê´€ë ¨ í”„ë ˆì„ {len(relevant_frames)}ê°œ ë°œê²¬:\n"
                        for i, frame in enumerate(relevant_frames, 1):
                            frame_summary += f"â€¢ í”„ë ˆì„ {i}: {frame['timestamp']:.1f}ì´ˆ (ê´€ë ¨ë„ {frame['relevance_score']:.2f}ì )\n"
                            
                            # í”„ë ˆì„ë³„ ì„¸ë¶€ ì •ë³´ ì¶”ê°€
                            if frame.get('persons'):
                                frame_summary += f"  ğŸ‘¤ ì‚¬ëŒ {len(frame['persons'])}ëª… ê°ì§€ë¨!\n"
                                # ê° ì‚¬ëŒì˜ ìƒì„¸ ì •ë³´ ì¶”ê°€
                                for j, person in enumerate(frame['persons'], 1):
                                    confidence = person.get('confidence', 0)
                                    frame_summary += f"    ì‚¬ëŒ {j}: ì‹ ë¢°ë„ {confidence:.2f}\n"
                                    # ì†ì„± ì •ë³´ ì¶”ê°€
                                    attrs = person.get('attributes', {})
                                    if 'gender' in attrs:
                                        gender_info = attrs['gender']
                                        frame_summary += f"      ì„±ë³„: {gender_info.get('value', 'unknown')}\n"
                                    if 'age' in attrs:
                                        age_info = attrs['age']
                                        frame_summary += f"      ë‚˜ì´: {age_info.get('value', 'unknown')}\n"
                            if frame.get('objects'):
                                frame_summary += f"  ğŸ“¦ ê°ì²´ {len(frame['objects'])}ê°œ ê°ì§€\n"
                            
                            scene_attrs = frame.get('scene_attributes', {})
                            if scene_attrs:
                                scene_type = scene_attrs.get('scene_type', 'unknown')
                                lighting = scene_attrs.get('lighting', 'unknown')
                                frame_summary += f"  ğŸï¸ ì¥ë©´: {scene_type}, ì¡°ëª…: {lighting}\n"
                        
                        frame_summary += "\nğŸ’¡ ìœ„ í”„ë ˆì„ë“¤ì„ ì°¸ê³ í•˜ì—¬ ì˜ìƒì—ì„œ í•´ë‹¹ ë‚´ìš©ì„ í™•ì¸í•´ë³´ì„¸ìš”."
                        optimal_response += frame_summary
                    
                    # í†µí•© ì‘ë‹µ ì €ì¥
                    optimal_message = VideoChatMessage.objects.create(
                        session=session,
                        message_type='ai_optimal',
                        content=optimal_response,
                        ai_model='optimal',
                        parent_message=user_message
                    )
                    
                except Exception as e:
                    print(f"í†µí•© ì‘ë‹µ ìƒì„± ì‹¤íŒ¨: {str(e)}")
                    optimal_response = f"í†µí•© ì‘ë‹µ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"
            elif ai_responses and len(ai_responses) == 1:
                # AI ì‘ë‹µì´ í•˜ë‚˜ë§Œ ìˆëŠ” ê²½ìš°
                optimal_response = list(ai_responses.values())[0]
            
            # ì‘ë‹µ í’ˆì§ˆ í‰ê°€
            evaluation_results = {}
            if ai_responses and len(ai_responses) > 1:
                try:
                    evaluation_results = evaluation_metrics.evaluate_summary_quality(
                        ai_responses, reference=optimal_response
                    )
                    print(f"âœ… ì‘ë‹µ í’ˆì§ˆ í‰ê°€ ì™„ë£Œ: {len(evaluation_results)}ê°œ AI")
                except Exception as e:
                    print(f"âŒ ì‘ë‹µ í’ˆì§ˆ í‰ê°€ ì‹¤íŒ¨: {e}")
            
            # ëŒ€í™” ë§¥ë½ ì—…ë°ì´íŠ¸
            try:
                conversation_memory.add_context(
                    session_id=session_id,
                    user_message=message,
                    ai_responses=ai_responses,
                    video_context={
                        'video_id': video_id,
                        'video_name': video.original_name,
                        'relevant_frames_count': len(relevant_frames)
                    }
                )
                print(f"âœ… ëŒ€í™” ë§¥ë½ ì—…ë°ì´íŠ¸ ì™„ë£Œ")
            except Exception as e:
                print(f"âŒ ëŒ€í™” ë§¥ë½ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            
            # ì‘ë‹µ ë°ì´í„° êµ¬ì„±
            response_data = {
                'session_id': str(session.id),
                'user_message': {
                    'id': str(user_message.id),
                    'content': message,
                    'created_at': user_message.created_at
                },
                'ai_responses': {
                    'individual': [
                        {
                            'id': str(msg.id),
                            'model': msg.ai_model,
                            'content': msg.content,
                            'created_at': msg.created_at
                        } for msg in individual_messages
                    ],
                    'optimal': {
                        'content': optimal_response,
                        'created_at': individual_messages[0].created_at if individual_messages else None
                    } if optimal_response else None
                },
                'relevant_frames': relevant_frames,  # ê´€ë ¨ í”„ë ˆì„ ì •ë³´ ì¶”ê°€
                'evaluation_results': evaluation_results,  # í’ˆì§ˆ í‰ê°€ ê²°ê³¼
                'context_info': {
                    'session_id': session_id,
                    'context_length': len(conversation_memory.get_context(session_id).get('conversations', []))
                }
            }
            
            # ë””ë²„ê¹…: relevant_frames í™•ì¸
            print(f"ğŸ” ì‘ë‹µ ìƒì„± ì‹œ relevant_frames: {len(relevant_frames)}")
            if relevant_frames:
                print(f"ğŸ“¸ ì²« ë²ˆì§¸ í”„ë ˆì„: {relevant_frames[0]}")
            else:
                print("âŒ relevant_framesê°€ ë¹„ì–´ìˆìŒ!")
            
            print(f"ğŸ“¤ ì‘ë‹µì— í¬í•¨ë  í”„ë ˆì„ ìˆ˜: {len(relevant_frames)}")
            if relevant_frames:
                print(f"ğŸ“¸ ì²« ë²ˆì§¸ í”„ë ˆì„: {relevant_frames[0]}")
            
            return Response(response_data)
            
        except Exception as e:
            import traceback
            print(f"âŒ VideoChatView POST ì˜¤ë¥˜: {str(e)}")
            print(f"âŒ ì˜¤ë¥˜ ìƒì„¸: {traceback.format_exc()}")
            return Response({
                'error': f'ì±„íŒ… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}',
                'traceback': traceback.format_exc()
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def _classify_intent(self, message):
        """ì‚¬ìš©ì ë©”ì‹œì§€ì˜ ì˜ë„ë¥¼ ë¶„ë¥˜"""
        try:
            message_lower = message.lower()
            
            # ì˜ë„ë³„ í‚¤ì›Œë“œ ì •ì˜
            intent_keywords = {
                'video_summary': ['ìš”ì•½', 'summary', 'ê°„ë‹¨', 'ìƒì„¸', 'í•˜ì´ë¼ì´íŠ¸', 'highlight', 'ì •ë¦¬'],
                'video_search': ['ì°¾ì•„', 'ê²€ìƒ‰', 'search', 'ë³´ì—¬', 'ì–´ë””', 'ì–¸ì œ', 'ëˆ„ê°€'],
                'person_search': ['ì‚¬ëŒ', 'person', 'people', 'human', 'ë‚¨ì„±', 'ì—¬ì„±', 'ì„±ë³„'],
                'color_search': ['ë¹¨ê°„ìƒ‰', 'íŒŒë€ìƒ‰', 'ë…¸ë€ìƒ‰', 'ì´ˆë¡ìƒ‰', 'ë³´ë¼ìƒ‰', 'ë¶„í™ìƒ‰', 'ê²€ì€ìƒ‰', 'í°ìƒ‰', 'íšŒìƒ‰', 'ì£¼í™©ìƒ‰', 'ê°ˆìƒ‰', 'ìƒ‰ê¹”', 'ìƒ‰ìƒ', 'ì˜·', 'ì…ì€', 'ì°©ìš©'],
                'temporal_analysis': ['ì‹œê°„', 'ë¶„', 'ì´ˆ', 'ì–¸ì œ', 'ëª‡ì‹œ', 'ì„±ë¹„', 'ì¸ì›', 'í†µê³„'],
                'inter_video_search': ['ë¹„ì˜¤ëŠ”', 'ë°¤', 'ë‚®', 'ë‚ ì”¨', 'ì¡°ëª…', 'ì˜ìƒê°„', 'ë‹¤ë¥¸ì˜ìƒ'],
                'general_chat': ['ì•ˆë…•', 'hello', 'hi', 'ê³ ë§ˆì›Œ', 'ê°ì‚¬', 'ë„ì›€', 'ì§ˆë¬¸']
            }
            
            # ì˜ë„ ì ìˆ˜ ê³„ì‚°
            intent_scores = {}
            for intent, keywords in intent_keywords.items():
                score = sum(1 for keyword in keywords if keyword in message_lower)
                if score > 0:
                    intent_scores[intent] = score
            
            # ê°€ì¥ ë†’ì€ ì ìˆ˜ì˜ ì˜ë„ ì„ íƒ
            if intent_scores:
                detected_intent = max(intent_scores, key=intent_scores.get)
                confidence = intent_scores[detected_intent] / len(message_lower.split())
                print(f"ğŸ¯ ì˜ë„ ë¶„ë¥˜: {detected_intent} (ì‹ ë¢°ë„: {confidence:.2f})")
                return detected_intent, confidence
            else:
                print("ğŸ¯ ì˜ë„ ë¶„ë¥˜: general_chat (ê¸°ë³¸ê°’)")
                return 'general_chat', 0.0
                
        except Exception as e:
            print(f"âŒ ì˜ë„ ë¶„ë¥˜ ì¤‘ ì˜¤ë¥˜: {e}")
            return 'general_chat', 0.0

    def _parse_time_range(self, message):
        """ë©”ì‹œì§€ì—ì„œ ì‹œê°„ ë²”ìœ„ë¥¼ íŒŒì‹±"""
        try:
            import re
            
            # ì‹œê°„ íŒ¨í„´ ë§¤ì¹­ (ì˜ˆ: "3:00~5:00", "3ë¶„~5ë¶„", "180ì´ˆ~300ì´ˆ")
            time_patterns = [
                r'(\d+):(\d+)~(\d+):(\d+)',  # 3:00~5:00
                r'(\d+)ë¶„~(\d+)ë¶„',          # 3ë¶„~5ë¶„
                r'(\d+)ì´ˆ~(\d+)ì´ˆ',          # 180ì´ˆ~300ì´ˆ
            ]
            
            for pattern in time_patterns:
                match = re.search(pattern, message)
                if match:
                    groups = match.groups()
                    if len(groups) == 4:  # 3:00~5:00 í˜•ì‹
                        start_min, start_sec, end_min, end_sec = map(int, groups)
                        start_time = start_min * 60 + start_sec
                        end_time = end_min * 60 + end_sec
                        return start_time, end_time
                    elif len(groups) == 2:  # ë¶„ ë˜ëŠ” ì´ˆ í˜•ì‹
                        start_val, end_val = map(int, groups)
                        if 'ë¶„' in message:
                            start_time = start_val * 60
                            end_time = end_val * 60
                        else:  # ì´ˆ
                            start_time = start_val
                            end_time = end_val
                        return start_time, end_time
            
            return None
            
        except Exception as e:
            print(f"âŒ ì‹œê°„ ë²”ìœ„ íŒŒì‹± ì¤‘ ì˜¤ë¥˜: {e}")
            return None

    def _find_relevant_frames(self, message, analysis_json_data, video_id):
        """ì‚¬ìš©ì ë©”ì‹œì§€ì— ë”°ë¼ ê´€ë ¨ í”„ë ˆì„ì„ ì°¾ì•„ì„œ ì´ë¯¸ì§€ URLê³¼ í•¨ê»˜ ë°˜í™˜ (ì˜ë„ ê¸°ë°˜)"""
        try:
            if not analysis_json_data or 'frame_results' not in analysis_json_data:
                print("âŒ ë¶„ì„ ë°ì´í„° ë˜ëŠ” í”„ë ˆì„ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.")
                return []
            
            relevant_frames = []
            message_lower = message.lower()
            
            # í”„ë ˆì„ ê²°ê³¼ì—ì„œ ë§¤ì¹­ë˜ëŠ” í”„ë ˆì„ ì°¾ê¸°
            frame_results = analysis_json_data.get('frame_results', [])
            print(f"ğŸ” ê²€ìƒ‰í•  í”„ë ˆì„ ìˆ˜: {len(frame_results)}")
            
            # ì˜ë„ ë¶„ë¥˜
            intent, confidence = self._classify_intent(message)
            print(f"ğŸ¯ ê²€ìƒ‰ ì˜ë„: {intent}")
            
            # ìƒ‰ìƒ ê¸°ë°˜ ê²€ìƒ‰
            color_keywords = {
                'ë¹¨ê°„ìƒ‰': ['red', 'ë¹¨ê°•', 'ë¹¨ê°„ìƒ‰'],
                'íŒŒë€ìƒ‰': ['blue', 'íŒŒë‘', 'íŒŒë€ìƒ‰'],
                'ë…¸ë€ìƒ‰': ['yellow', 'ë…¸ë‘', 'ë…¸ë€ìƒ‰'],
                'ì´ˆë¡ìƒ‰': ['green', 'ë…¹ìƒ‰', 'ì´ˆë¡ìƒ‰'],
                'ë³´ë¼ìƒ‰': ['purple', 'ìì£¼ìƒ‰', 'ë³´ë¼ìƒ‰'],
                'ë¶„í™ìƒ‰': ['pink', 'í•‘í¬', 'ë¶„í™ìƒ‰'],
                'ê²€ì€ìƒ‰': ['black', 'ê²€ì •', 'ê²€ì€ìƒ‰'],
                'í°ìƒ‰': ['white', 'í•˜ì–‘', 'í°ìƒ‰'],
                'íšŒìƒ‰': ['gray', 'grey', 'íšŒìƒ‰'],
                'ì£¼í™©ìƒ‰': ['orange', 'ì˜¤ë Œì§€', 'ì£¼í™©ìƒ‰'],
                'ê°ˆìƒ‰': ['brown', 'ë¸Œë¼ìš´', 'ê°ˆìƒ‰'],
                'ì˜·': ['clothing', 'clothes', 'dress', 'shirt', 'pants', 'jacket']
            }
            
            # ì˜ë„ ê¸°ë°˜ í”„ë ˆì„ ê²€ìƒ‰
            if intent == 'color_search':
                print("ğŸ¨ ìƒ‰ìƒ ê²€ìƒ‰ ëª¨ë“œ")
                detected_colors = []
                for color_korean, color_terms in color_keywords.items():
                    if any(term in message_lower for term in color_terms):
                        detected_colors.append(color_korean)
                        print(f"ğŸ¨ ìƒ‰ìƒ ê²€ìƒ‰ ê°ì§€: {color_korean}")
                
                if detected_colors:
                    print(f"ğŸ¨ ìƒ‰ìƒ ê²€ìƒ‰ ëª¨ë“œ: {detected_colors}")
                    print(f"ğŸ” ê²€ìƒ‰í•  í”„ë ˆì„ ìˆ˜: {len(frame_results)}")
                    for frame in frame_results:
                        persons = frame.get('persons', [])
                        
                        # ìƒ‰ìƒ ë¶„ì„ ê²°ê³¼ í™•ì¸
                        dominant_colors = frame.get('dominant_colors', [])
                        color_match_found = False
                        
                        # ìš”ì²­ëœ ìƒ‰ìƒê³¼ ë§¤ì¹­ë˜ëŠ”ì§€ í™•ì¸ (ë” ìœ ì—°í•œ ë§¤ì¹­)
                        for detected_color in detected_colors:
                            for color_info in dominant_colors:
                                color_name = color_info.get('color', '').lower()
                                detected_color_lower = detected_color.lower()
                                
                                # ìƒ‰ìƒ í‚¤ì›Œë“œ ë§¤í•‘ì„ í†µí•œ ë§¤ì¹­
                                color_mapping = {
                                    'ë¶„í™ìƒ‰': 'pink', 'í•‘í¬': 'pink',
                                    'ë¹¨ê°„ìƒ‰': 'red', 'ë¹¨ê°•': 'red',
                                    'íŒŒë€ìƒ‰': 'blue', 'íŒŒë‘': 'blue',
                                    'ë…¸ë€ìƒ‰': 'yellow', 'ë…¸ë‘': 'yellow',
                                    'ì´ˆë¡ìƒ‰': 'green', 'ë…¹ìƒ‰': 'green',
                                    'ë³´ë¼ìƒ‰': 'purple', 'ìì£¼ìƒ‰': 'purple',
                                    'ê²€ì€ìƒ‰': 'black', 'ê²€ì •': 'black',
                                    'í°ìƒ‰': 'white', 'í•˜ì–‘': 'white',
                                    'íšŒìƒ‰': 'gray', 'grey': 'gray',
                                    'ì£¼í™©ìƒ‰': 'orange', 'ì˜¤ë Œì§€': 'orange',
                                    'ê°ˆìƒ‰': 'brown', 'ë¸Œë¼ìš´': 'brown'
                                }
                                
                                # ë§¤í•‘ëœ ìƒ‰ìƒìœ¼ë¡œ ë¹„êµ
                                mapped_color = color_mapping.get(detected_color_lower, detected_color_lower)
                                
                                # ë” ìœ ì—°í•œ ìƒ‰ìƒ ë§¤ì¹­ (ìƒ‰ìƒì´ ì—†ì–´ë„ ì¼ë‹¨ í¬í•¨)
                                if (mapped_color == color_name or 
                                    detected_color_lower == color_name or 
                                    detected_color_lower in color_name or 
                                    color_name in detected_color_lower or
                                    len(dominant_colors) == 0):  # ìƒ‰ìƒ ì •ë³´ê°€ ì—†ì–´ë„ í¬í•¨
                                    color_match_found = True
                                    print(f"âœ… ìƒ‰ìƒ ë§¤ì¹­ ë°œê²¬: {detected_color} -> {color_info}")
                                    break
                            if color_match_found:
                                break
                        
                        # ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê·¸ ì¶”ê°€
                        print(f"ğŸ” í”„ë ˆì„ {frame.get('image_id', 0)} ìƒ‰ìƒ ë¶„ì„:")
                        print(f"  - ìš”ì²­ëœ ìƒ‰ìƒ: {detected_colors}")
                        print(f"  - ê°ì§€ëœ ìƒ‰ìƒ: {[c.get('color', '') for c in dominant_colors]}")
                        print(f"  - ë§¤ì¹­ ê²°ê³¼: {color_match_found}")
                        
                        # ìƒ‰ìƒ ê²€ìƒ‰ì˜ ê²½ìš° ìƒ‰ìƒ ë§¤ì¹­ì´ ëœ í”„ë ˆì„ë§Œ í¬í•¨
                        if color_match_found:
                            frame_image_path = frame.get('frame_image_path', '')
                            actual_image_path = None
                            if frame_image_path:
                                # ì‹¤ì œ íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œ ìƒì„±
                                import os
                                from django.conf import settings
                                actual_image_path = os.path.join(settings.MEDIA_ROOT, frame_image_path)
                                if os.path.exists(actual_image_path):
                                    print(f"âœ… ì‹¤ì œ ì´ë¯¸ì§€ íŒŒì¼ ì¡´ì¬: {actual_image_path}")
                                else:
                                    print(f"âŒ ì‹¤ì œ ì´ë¯¸ì§€ íŒŒì¼ ì—†ìŒ: {actual_image_path}")
                            
                            frame_info = {
                                'image_id': frame.get('image_id', 0),
                                'timestamp': frame.get('timestamp', 0),
                                'frame_image_path': frame_image_path,
                                'image_url': f'/media/{frame_image_path}',
                                'actual_image_path': actual_image_path,  # ì‹¤ì œ íŒŒì¼ ê²½ë¡œ ì¶”ê°€
                                'persons': persons,
                                'objects': frame.get('objects', []),
                                'scene_attributes': frame.get('scene_attributes', {}),
                                'dominant_colors': dominant_colors,  # ìƒ‰ìƒ ë¶„ì„ ê²°ê³¼ ì¶”ê°€
                                'relevance_score': 2,  # ìƒ‰ìƒ ë§¤ì¹­ ì‹œ ë†’ì€ ì ìˆ˜
                                'color_search_info': {
                                    'requested_colors': detected_colors,
                                    'color_info_available': len(dominant_colors) > 0,
                                    'color_match_found': color_match_found,
                                    'actual_image_available': actual_image_path is not None,
                                    'message': f"ìƒ‰ìƒ ë¶„ì„ ê²°ê³¼: {dominant_colors} | ìš”ì²­í•˜ì‹  ìƒ‰ìƒ: {', '.join(detected_colors)}"
                                }
                            }
                            relevant_frames.append(frame_info)
                            print(f"âœ… í”„ë ˆì„ {frame_info['image_id']} ì¶”ê°€ (ìƒ‰ìƒ ë§¤ì¹­ ì„±ê³µ)")
                        else:
                            print(f"âŒ í”„ë ˆì„ {frame.get('image_id', 0)}: ìƒ‰ìƒ ë§¤ì¹­ ì‹¤íŒ¨ - {detected_colors} vs {dominant_colors}")
                
                else:
                    print("ğŸ¨ ìƒ‰ìƒ í‚¤ì›Œë“œ ê°ì§€ ì‹¤íŒ¨ - ì¼ë°˜ ê²€ìƒ‰ìœ¼ë¡œ ì „í™˜")
                    # ìƒ‰ìƒ í‚¤ì›Œë“œê°€ ê°ì§€ë˜ì§€ ì•Šìœ¼ë©´ ëª¨ë“  í”„ë ˆì„ í¬í•¨
                    for frame in frame_results:
                        persons = frame.get('persons', [])
                        if persons:  # ì‚¬ëŒì´ ìˆëŠ” í”„ë ˆì„ë§Œ
                            frame_info = {
                                'image_id': frame.get('image_id', 0),
                                'timestamp': frame.get('timestamp', 0),
                                'frame_image_path': frame.get('frame_image_path', ''),
                                'image_url': f'/media/{frame.get("frame_image_path", "")}',
                                'persons': persons,
                                'objects': frame.get('objects', []),
                                'scene_attributes': frame.get('scene_attributes', {}),
                                'relevance_score': len(persons)
                            }
                            relevant_frames.append(frame_info)
                            print(f"âœ… í”„ë ˆì„ {frame_info['image_id']} ì¶”ê°€ (ì¼ë°˜ ê²€ìƒ‰, ì‚¬ëŒ {len(persons)}ëª…)")
            
            elif intent == 'person_search':
                print("ğŸ‘¤ ì‚¬ëŒ ê²€ìƒ‰ ëª¨ë“œ")
                print(f"ğŸ” ê²€ìƒ‰í•  í”„ë ˆì„ ìˆ˜: {len(frame_results)}")
                for frame in frame_results:
                    persons = frame.get('persons', [])
                    print(f"ğŸ” í”„ë ˆì„ {frame.get('image_id', 0)}: persons = {persons}")
                    # ì‚¬ëŒì´ ê°ì§€ëœ í”„ë ˆì„ë§Œ í¬í•¨
                    if persons and len(persons) > 0:
                        frame_info = {
                            'image_id': frame.get('image_id', 0),
                            'timestamp': frame.get('timestamp', 0),
                            'frame_image_path': frame.get('frame_image_path', ''),
                            'image_url': f'/media/{frame.get("frame_image_path", "")}',
                            'persons': persons,
                            'objects': frame.get('objects', []),
                            'scene_attributes': frame.get('scene_attributes', {}),
                            'relevance_score': len(persons) * 2  # ì‚¬ëŒ ìˆ˜ì— ë¹„ë¡€í•œ ì ìˆ˜
                        }
                        relevant_frames.append(frame_info)
                        print(f"âœ… í”„ë ˆì„ {frame_info['image_id']} ì¶”ê°€ (ì‚¬ëŒ {len(persons)}ëª… ê°ì§€)")
                        print(f"âœ… í”„ë ˆì„ ìƒì„¸ ì •ë³´: {frame_info}")
                    else:
                        print(f"âŒ í”„ë ˆì„ {frame.get('image_id', 0)}: ì‚¬ëŒ ê°ì§€ ì•ˆë¨")
            
            elif intent == 'video_summary':
                print("ğŸ“‹ ìš”ì•½ ëª¨ë“œ - ì£¼ìš” í”„ë ˆì„ ì„ íƒ")
                # í™œë™ ìˆ˜ì¤€ì´ ë†’ì€ í”„ë ˆì„ ìš°ì„  ì„ íƒ
                frame_scores = []
                for frame in frame_results:
                    scene_attrs = frame.get('scene_attributes', {})
                    activity_level = scene_attrs.get('activity_level', 'low')
                    person_count = len(frame.get('persons', []))
                    
                    score = 0
                    if activity_level == 'high':
                        score += 3
                    elif activity_level == 'medium':
                        score += 2
                    else:
                        score += 1
                    
                    score += min(person_count, 3)  # ì‚¬ëŒ ìˆ˜ì— ë”°ë¥¸ ì ìˆ˜
                    frame_scores.append((frame, score))
                
                # ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ìƒìœ„ í”„ë ˆì„ ì„ íƒ
                frame_scores.sort(key=lambda x: x[1], reverse=True)
                for frame, score in frame_scores[:3]:
                    frame_info = {
                        'image_id': frame.get('image_id', 0),
                        'timestamp': frame.get('timestamp', 0),
                        'frame_image_path': frame.get('frame_image_path', ''),
                        'image_url': f'/media/{frame.get("frame_image_path", "")}',
                        'persons': frame.get('persons', []),
                        'objects': frame.get('objects', []),
                        'scene_attributes': frame.get('scene_attributes', {}),
                        'relevance_score': score
                    }
                    relevant_frames.append(frame_info)
                    print(f"âœ… í”„ë ˆì„ {frame_info['image_id']} ì¶”ê°€ (ìš”ì•½ìš©, ì ìˆ˜: {score})")
            
            elif intent == 'temporal_analysis':
                print("â° ì‹œê°„ëŒ€ ë¶„ì„ ëª¨ë“œ")
                # ì‹œê°„ ë²”ìœ„ íŒŒì‹±
                time_range = self._parse_time_range(message)
                if time_range:
                    start_time, end_time = time_range
                    print(f"â° ì‹œê°„ ë²”ìœ„: {start_time}ì´ˆ ~ {end_time}ì´ˆ")
                    for frame in frame_results:
                        timestamp = frame.get('timestamp', 0)
                        if start_time <= timestamp <= end_time:
                            frame_info = {
                                'image_id': frame.get('image_id', 0),
                                'timestamp': frame.get('timestamp', 0),
                                'frame_image_path': frame.get('frame_image_path', ''),
                                'image_url': f'/media/{frame.get("frame_image_path", "")}',
                                'persons': frame.get('persons', []),
                                'objects': frame.get('objects', []),
                                'scene_attributes': frame.get('scene_attributes', {}),
                                'relevance_score': 1
                            }
                            relevant_frames.append(frame_info)
                            print(f"âœ… í”„ë ˆì„ {frame_info['image_id']} ì¶”ê°€ (ì‹œê°„ëŒ€: {timestamp}ì´ˆ)")
                else:
                    # ì‹œê°„ ë²”ìœ„ë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ì „ì²´ í”„ë ˆì„
                    relevant_frames = [{
                        'image_id': frame.get('image_id', 0),
                        'timestamp': frame.get('timestamp', 0),
                        'frame_image_path': frame.get('frame_image_path', ''),
                        'image_url': f'/media/{frame.get("frame_image_path", "")}',
                        'persons': frame.get('persons', []),
                        'objects': frame.get('objects', []),
                        'scene_attributes': frame.get('scene_attributes', {}),
                        'relevance_score': 1
                    } for frame in frame_results]
                    print(f"âœ… ì‹œê°„ ë²”ìœ„ íŒŒì‹± ì‹¤íŒ¨ - ì „ì²´ í”„ë ˆì„ {len(relevant_frames)}ê°œ ì„ íƒ")
            
            else:
                print("ğŸ“‹ ì¼ë°˜ ê²€ìƒ‰ ëª¨ë“œ")
                # ì²˜ìŒ 2ê°œ í”„ë ˆì„ ì„ íƒ
                for frame in frame_results[:2]:
                    frame_info = {
                        'image_id': frame.get('image_id', 0),
                        'timestamp': frame.get('timestamp', 0),
                        'frame_image_path': frame.get('frame_image_path', ''),
                        'image_url': f'/media/{frame.get("frame_image_path", "")}',
                        'persons': frame.get('persons', []),
                        'objects': frame.get('objects', []),
                        'scene_attributes': frame.get('scene_attributes', {}),
                        'relevance_score': 1
                    }
                    relevant_frames.append(frame_info)
                    print(f"âœ… í”„ë ˆì„ {frame_info['image_id']} ì¶”ê°€ (ì¼ë°˜ ê²€ìƒ‰)")
            
            # ê´€ë ¨ë„ ì ìˆ˜ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³  ìƒìœ„ 3ê°œë§Œ ë°˜í™˜
            relevant_frames.sort(key=lambda x: x['relevance_score'], reverse=True)
            result = relevant_frames[:3]
            print(f"ğŸ¯ ìµœì¢… ì„ íƒëœ í”„ë ˆì„ ìˆ˜: {len(result)}")
            print(f"ğŸ¯ ìµœì¢… í”„ë ˆì„ ìƒì„¸: {result}")
            return result
            
        except Exception as e:
            print(f"âŒ í”„ë ˆì„ ê²€ìƒ‰ ì‹¤íŒ¨: {e}")
            return []
    
    def _handle_special_commands(self, message, video_id):
        """íŠ¹ë³„ ëª…ë ¹ì–´ ì²˜ë¦¬ (ìš”ì•½, í•˜ì´ë¼ì´íŠ¸)"""
        try:
            message_lower = message.lower().strip()
            
            # ì˜ìƒ ìš”ì•½ ëª…ë ¹ì–´
            if any(keyword in message_lower for keyword in ['ìš”ì•½', 'summary', 'ì˜ìƒ ìš”ì•½', 'ì˜ìƒ ìš”ì•½í•´ì¤˜', 'ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ì•Œë ¤ì¤˜']):
                return self._handle_video_summary_command(message_lower, video_id)
            
            # ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ëª…ë ¹ì–´
            elif any(keyword in message_lower for keyword in ['í•˜ì´ë¼ì´íŠ¸', 'highlight', 'ì£¼ìš” ì¥ë©´', 'ì¤‘ìš”í•œ ì¥ë©´']):
                return self._handle_video_highlight_command(message_lower, video_id)
            
            return None
            
        except Exception as e:
            logger.error(f"âŒ íŠ¹ë³„ ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            return None
    
    def _handle_video_summary_command(self, message, video_id):
        """ì˜ìƒ ìš”ì•½ ëª…ë ¹ì–´ ì²˜ë¦¬"""
        try:
            # ìš”ì•½ íƒ€ì… ê²°ì •
            summary_type = 'comprehensive'
            if 'ê°„ë‹¨' in message or 'brief' in message:
                summary_type = 'brief'
            elif 'ìƒì„¸' in message or 'detailed' in message:
                summary_type = 'detailed'
            
            # VideoSummaryView ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ìš”ì•½ ìƒì„±
            summary_view = VideoSummaryView()
            summary_result = summary_view._generate_video_summary(
                Video.objects.get(id=video_id), 
                summary_type
            )
            
            if summary_result and summary_result.get('summary'):
                return f"ğŸ“ **ì˜ìƒ ìš”ì•½** ({summary_type})\n\n{summary_result['summary']}"
            else:
                return "âŒ ì˜ìƒ ìš”ì•½ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜ìƒ ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”."
                
        except Exception as e:
            logger.error(f"âŒ ì˜ìƒ ìš”ì•½ ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            return f"âŒ ì˜ìƒ ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"
    
    def _handle_video_highlight_command(self, message, video_id):
        """ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ëª…ë ¹ì–´ ì²˜ë¦¬"""
        try:
            # í•˜ì´ë¼ì´íŠ¸ ê¸°ì¤€ ì„¤ì •
            criteria = {
                'min_score': 2.0,
                'max_highlights': 5
            }
            
            if 'ë§ì´' in message or 'more' in message:
                criteria['max_highlights'] = 10
            elif 'ì ê²Œ' in message or 'few' in message:
                criteria['max_highlights'] = 3
            
            # VideoHighlightView ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ
            highlight_view = VideoHighlightView()
            highlights = highlight_view._extract_highlights(
                Video.objects.get(id=video_id), 
                criteria
            )
            
            if highlights:
                highlight_text = "ğŸ¬ **ì˜ìƒ í•˜ì´ë¼ì´íŠ¸**\n\n"
                for i, highlight in enumerate(highlights, 1):
                    highlight_text += f"{i}. **{highlight['timestamp']:.1f}ì´ˆ** - {highlight['description']}\n"
                    highlight_text += f"   - ì¤‘ìš”ë„: {highlight['significance']} (ì ìˆ˜: {highlight['score']:.1f})\n"
                    highlight_text += f"   - ì¸ì›: {highlight['person_count']}ëª…, ì¥ë©´: {highlight['scene_type']}\n\n"
                
                return highlight_text
            else:
                return "âŒ í•˜ì´ë¼ì´íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜ìƒ ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”."
                
        except Exception as e:
            logger.error(f"âŒ ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            return f"âŒ ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"

class FrameImageView(APIView):
    """í”„ë ˆì„ ì´ë¯¸ì§€ ì„œë¹™"""
    permission_classes = [AllowAny]
    
    def get(self, request, video_id, frame_number):
        try:
            from django.conf import settings
            # í”„ë ˆì„ ì´ë¯¸ì§€ ê²½ë¡œ ìƒì„±
            frame_filename = f"video{video_id}_frame{frame_number}.jpg"
            frame_path = os.path.join(settings.MEDIA_ROOT, 'images', frame_filename)
            
            # íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
            if not os.path.exists(frame_path):
                raise Http404("í”„ë ˆì„ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            
            # ì´ë¯¸ì§€ íŒŒì¼ ì½ê¸°
            with open(frame_path, 'rb') as f:
                image_data = f.read()
            
            # HTTP ì‘ë‹µìœ¼ë¡œ ì´ë¯¸ì§€ ë°˜í™˜
            response = HttpResponse(image_data, content_type='image/jpeg')
            response['Content-Disposition'] = f'inline; filename="{frame_filename}"'
            return response
            
        except Exception as e:
            return Response({
                'error': f'í”„ë ˆì„ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: {str(e)}'
            }, status=status.HTTP_404_NOT_FOUND)


class VideoSummaryView(APIView):
    """ì˜ìƒ ìš”ì•½ ê¸°ëŠ¥"""
    permission_classes = [AllowAny]
    
    def post(self, request):
        try:
            video_id = request.data.get('video_id')
            summary_type = request.data.get('summary_type', 'comprehensive')  # comprehensive, brief, detailed
            
            logger.info(f"ğŸ“ ì˜ìƒ ìš”ì•½ ìš”ì²­: ë¹„ë””ì˜¤={video_id}, íƒ€ì…={summary_type}")
            
            if not video_id:
                return Response({'error': 'ë¹„ë””ì˜¤ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.'}, status=400)
            
            try:
                video = Video.objects.get(id=video_id)
            except Video.DoesNotExist:
                return Response({'error': 'ë¹„ë””ì˜¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'}, status=404)
            
            # ì˜ìƒ ìš”ì•½ ìƒì„±
            summary_result = self._generate_video_summary(video, summary_type)
            
            return Response({
                'video_id': video_id,
                'video_name': video.original_name,
                'summary_type': summary_type,
                'summary_result': summary_result,
                'analysis_type': 'video_summary'
            })
            
        except Exception as e:
            logger.error(f"âŒ ì˜ìƒ ìš”ì•½ ì˜¤ë¥˜: {e}")
            return Response({'error': str(e)}, status=500)
    
    def _generate_video_summary(self, video, summary_type):
        """ì˜ìƒ ìš”ì•½ ìƒì„±"""
        try:
            # ë¶„ì„ ê²°ê³¼ JSON íŒŒì¼ ì½ê¸°
            if not video.analysis_json_path:
                return {
                    'summary': 'ë¶„ì„ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ì˜ìƒ ë¶„ì„ì„ ë¨¼ì € ì™„ë£Œí•´ì£¼ì„¸ìš”.',
                    'key_events': [],
                    'statistics': {},
                    'duration': video.duration,
                    'frame_count': 0
                }
            
            json_path = os.path.join(settings.MEDIA_ROOT, video.analysis_json_path)
            if not os.path.exists(json_path):
                return {
                    'summary': 'ë¶„ì„ ê²°ê³¼ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
                    'key_events': [],
                    'statistics': {},
                    'duration': video.duration,
                    'frame_count': 0
                }
            
            with open(json_path, 'r', encoding='utf-8') as f:
                analysis_data = json.load(f)
            
            # ê¸°ë³¸ í†µê³„ ìˆ˜ì§‘
            statistics = self._collect_video_statistics(video, analysis_data)
            
            # í‚¤ ì´ë²¤íŠ¸ ì¶”ì¶œ
            key_events = self._extract_key_events(analysis_data)
            
            # ìš”ì•½ íƒ€ì…ì— ë”°ë¥¸ ì²˜ë¦¬
            if summary_type == 'brief':
                summary_text = self._generate_brief_summary(statistics, key_events)
            elif summary_type == 'detailed':
                summary_text = self._generate_detailed_summary(statistics, key_events, analysis_data)
            else:  # comprehensive
                summary_text = self._generate_comprehensive_summary(statistics, key_events, analysis_data)
            
            return {
                'summary': summary_text,
                'key_events': key_events,
                'statistics': statistics,
                'duration': video.duration,
                'frame_count': len(analysis_data.get('frame_results', [])),
                'summary_type': summary_type
            }
            
        except Exception as e:
            logger.error(f"âŒ ì˜ìƒ ìš”ì•½ ìƒì„± ì˜¤ë¥˜: {e}")
            return {
                'summary': f'ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}',
                'key_events': [],
                'statistics': {},
                'duration': video.duration,
                'frame_count': 0
            }
    
    def _collect_video_statistics(self, video, analysis_data):
        """ì˜ìƒ í†µê³„ ìˆ˜ì§‘ - ğŸ’¡í•µì‹¬ ì¸ì‚¬ì´íŠ¸ í¬í•¨"""
        try:
            video_summary = analysis_data.get('video_summary', {})
            frame_results = analysis_data.get('frame_results', [])
            
            # ê¸°ë³¸ í†µê³„
            stats = {
                'total_duration': video.duration,
                'total_frames': len(frame_results),
                'total_detections': video_summary.get('total_detections', 0),
                'unique_persons': video_summary.get('unique_persons', 0),
                'quality_score': video_summary.get('quality_assessment', {}).get('overall_score', 0),
                'scene_diversity': video_summary.get('scene_diversity', {}).get('diversity_score', 0)
            }
            
            # ì‹œê°„ëŒ€ë³„ í™œë™ ë¶„ì„
            temporal_analysis = video_summary.get('temporal_analysis', {})
            stats.update({
                'peak_time': temporal_analysis.get('peak_time_seconds', 0),
                'peak_person_count': temporal_analysis.get('peak_person_count', 0),
                'average_person_count': temporal_analysis.get('average_person_count', 0)
            })
            
            # ì¥ë©´ íŠ¹ì„± ë¶„ì„
            scene_distribution = video_summary.get('scene_diversity', {})
            stats.update({
                'scene_types': scene_distribution.get('scene_type_distribution', {}),
                'activity_levels': scene_distribution.get('activity_level_distribution', {}),
                'lighting_types': scene_distribution.get('lighting_distribution', {})
            })
            
            # ğŸ’¡ í•µì‹¬ ì¸ì‚¬ì´íŠ¸ ìƒì„±
            stats['key_insights'] = self._generate_key_insights_for_summary(stats, frame_results)
            
            return stats
            
        except Exception as e:
            logger.error(f"âŒ í†µê³„ ìˆ˜ì§‘ ì˜¤ë¥˜: {e}")
            return {}
    
    def _generate_key_insights_for_summary(self, stats, frame_results):
        """ğŸ’¡ í•µì‹¬ ì¸ì‚¬ì´íŠ¸ ìƒì„± (ì˜ìƒ ìš”ì•½ìš©)"""
        insights = []
        
        try:
            # 1. ì¸ì› êµ¬ì„± ì¸ì‚¬ì´íŠ¸
            person_count = stats.get('unique_persons', 0)
            peak_count = stats.get('peak_person_count', 0)
            
            if person_count > 0:
                if peak_count > 5:
                    insights.append(f"ë‹¤ìˆ˜ ì¸ì› ë“±ì¥ (ìµœëŒ€ {peak_count}ëª… ë™ì‹œ ë“±ì¥)")
                elif peak_count > 2:
                    insights.append(f"ì†Œê·œëª¨ ê·¸ë£¹ í™œë™ ({peak_count}ëª…)")
                else:
                    insights.append(f"ì†Œìˆ˜ ì¸ì› ì˜ìƒ ({person_count}ëª…)")
            
            # 2. ì˜ìƒ ê¸¸ì´ ì¸ì‚¬ì´íŠ¸
            duration = stats.get('total_duration', 0)
            if duration > 300:  # 5ë¶„ ì´ìƒ
                insights.append(f"ê¸´ ì˜ìƒ ({duration/60:.1f}ë¶„)")
            elif duration > 60:
                insights.append(f"ì¤‘ê°„ ê¸¸ì´ ì˜ìƒ ({duration/60:.1f}ë¶„)")
            else:
                insights.append(f"ì§§ì€ ì˜ìƒ ({duration:.0f}ì´ˆ)")
            
            # 3. í’ˆì§ˆ ì¸ì‚¬ì´íŠ¸
            quality_score = stats.get('quality_score', 0)
            if quality_score > 0.8:
                insights.append(f"ë†’ì€ í’ˆì§ˆ (ì ìˆ˜: {quality_score:.2f})")
            elif quality_score > 0.6:
                insights.append(f"ì–‘í˜¸í•œ í’ˆì§ˆ (ì ìˆ˜: {quality_score:.2f})")
            elif quality_score > 0:
                insights.append(f"ë³´í†µ í’ˆì§ˆ (ì ìˆ˜: {quality_score:.2f})")
            
            # 4. ì¥ë©´ ë‹¤ì–‘ì„± ì¸ì‚¬ì´íŠ¸
            scene_types = stats.get('scene_types', {})
            if len(scene_types) > 3:
                insights.append(f"ë‹¤ì–‘í•œ ì¥ë©´ í¬í•¨ ({len(scene_types)}ê°€ì§€ ì¥ì†Œ)")
            elif len(scene_types) > 0:
                main_scenes = list(scene_types.keys())[:2]
                insights.append(f"ì£¼ìš” ì¥ì†Œ: {', '.join(main_scenes)}")
            
            # 5. í™œë™ ìˆ˜ì¤€ ì¸ì‚¬ì´íŠ¸
            activity_levels = stats.get('activity_levels', {})
            if 'high' in activity_levels:
                insights.append(f"í™œë°œí•œ í™œë™ ê°ì§€")
            elif 'medium' in activity_levels:
                insights.append(f"ì¤‘ê°„ ìˆ˜ì¤€ í™œë™")
            
            return insights[:5]  # ìµœëŒ€ 5ê°œ ì¸ì‚¬ì´íŠ¸
            
        except Exception as e:
            logger.error(f"âŒ í•µì‹¬ ì¸ì‚¬ì´íŠ¸ ìƒì„± ì˜¤ë¥˜: {e}")
            return ["ì˜ìƒ ë¶„ì„ ì™„ë£Œ"]
    
    def _extract_key_events(self, analysis_data):
        """í‚¤ ì´ë²¤íŠ¸ ì¶”ì¶œ"""
        try:
            key_events = []
            frame_results = analysis_data.get('frame_results', [])
            
            # ì‚¬ëŒ ìˆ˜ê°€ ë§ì€ ì¥ë©´ë“¤ì„ í‚¤ ì´ë²¤íŠ¸ë¡œ ì„ ì •
            for frame in frame_results:
                person_count = len(frame.get('persons', []))
                if person_count >= 2:  # 2ëª… ì´ìƒì´ ìˆëŠ” ì¥ë©´
                    key_events.append({
                        'timestamp': frame.get('timestamp', 0),
                        'description': f"{person_count}ëª…ì´ ê°ì§€ëœ ì¥ë©´",
                        'person_count': person_count,
                        'scene_type': frame.get('scene_attributes', {}).get('scene_type', 'unknown'),
                        'activity_level': frame.get('scene_attributes', {}).get('activity_level', 'medium')
                    })
            
            # ì‹œê°„ìˆœìœ¼ë¡œ ì •ë ¬
            key_events.sort(key=lambda x: x['timestamp'])
            
            return key_events[:10]  # ìƒìœ„ 10ê°œë§Œ ë°˜í™˜
            
        except Exception as e:
            logger.error(f"âŒ í‚¤ ì´ë²¤íŠ¸ ì¶”ì¶œ ì˜¤ë¥˜: {e}")
            return []
    
    def _generate_brief_summary(self, statistics, key_events):
        """ê°„ë‹¨ ìš”ì•½ (1-2ë¬¸ì¥, ğŸ’¡í•µì‹¬ë§Œ ê°•ì¡°)"""
        try:
            duration = statistics.get('total_duration', 0)
            duration_min = duration / 60
            person_count = statistics.get('unique_persons', 0)
            key_insights = statistics.get('key_insights', [])
            
            # ê°€ì¥ ì¤‘ìš”í•œ í•µì‹¬ 1ê°œ + ê¸°ë³¸ ì •ë³´
            main_insight = key_insights[0] if key_insights else "ì˜ìƒ ë¶„ì„ ì™„ë£Œ"
            
            return f"ğŸ’¡ {main_insight}. ì˜ìƒ ê¸¸ì´ {duration_min:.1f}ë¶„, ì´ {person_count}ëª… ë“±ì¥."
            
        except Exception as e:
            logger.error(f"âŒ ê°„ë‹¨ ìš”ì•½ ìƒì„± ì˜¤ë¥˜: {e}")
            return "ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
    
    def _generate_detailed_summary(self, statistics, key_events, analysis_data):
        """ìƒì„¸ ìš”ì•½ (ë¬¸ë‹¨ í˜•ì‹, ğŸ’¡í•µì‹¬ 3ê°œ + ì£¼ìš” ì´ë²¤íŠ¸)"""
        try:
            duration = statistics.get('total_duration', 0)
            duration_min = duration / 60
            person_count = statistics.get('unique_persons', 0)
            peak_count = statistics.get('peak_person_count', 0)
            key_insights = statistics.get('key_insights', [])
            
            parts = [
                f"ğŸ“¹ ì´ ì˜ìƒì€ {duration_min:.1f}ë¶„ ê¸¸ì´ë¡œ, ì´ {person_count}ëª…ì´ ë“±ì¥í•©ë‹ˆë‹¤.",
                "\nğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸:",
                *[f"  â€¢ {insight}" for insight in key_insights[:3]]
            ]
            
            # ì£¼ìš” ì´ë²¤íŠ¸ 3ê°œ
            if key_events:
                parts.append("\nâ±ï¸ ì£¼ìš” ì¥ë©´:")
                for i, event in enumerate(key_events[:3], 1):
                    timestamp = event.get('timestamp', 0)
                    time_str = f"{int(timestamp//60)}:{int(timestamp%60):02d}"
                    desc = event.get('description', 'ì¥ë©´')[:50]
                    parts.append(f"  {i}. [{time_str}] {desc}")
            
            # í’ˆì§ˆ ì •ë³´
            quality_score = statistics.get('quality_score', 0)
            if quality_score > 0:
                quality_status = "ìš°ìˆ˜" if quality_score > 0.8 else "ì–‘í˜¸" if quality_score > 0.6 else "ë³´í†µ"
                parts.append(f"\nğŸ¯ ì˜ìƒ í’ˆì§ˆ: {quality_status} ({quality_score:.2f}/1.0)")
            
            # ì¥ë©´ ìœ í˜•
            scene_types = statistics.get('scene_types', {})
            if scene_types:
                scene_list = [f"{k}({v})" for k, v in list(scene_types.items())[:3]]
                parts.append(f"\nğŸ¬ ì¥ë©´ ìœ í˜•: {', '.join(scene_list)}")
            
            return "\n".join(parts)
            
        except Exception as e:
            logger.error(f"âŒ ìƒì„¸ ìš”ì•½ ìƒì„± ì˜¤ë¥˜: {e}")
            return "ìƒì„¸ ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
    
    def _generate_comprehensive_summary(self, statistics, key_events, analysis_data):
        """ì¢…í•© ìš”ì•½ (ì „ì²´ ë¶„ì„, ğŸ’¡í•µì‹¬ 5ê°œ + ëª¨ë“  ì´ë²¤íŠ¸ + í†µê³„)"""
        try:
            duration = statistics.get('total_duration', 0)
            duration_min = duration / 60
            person_count = statistics.get('unique_persons', 0)
            peak_count = statistics.get('peak_person_count', 0)
            key_insights = statistics.get('key_insights', [])
            
            parts = [
                f"ğŸ“¹ ì˜ìƒ ì •ë³´",
                f"  â€¢ ê¸¸ì´: {duration_min:.1f}ë¶„",
                f"  â€¢ ë“±ì¥ ì¸ì›: {person_count}ëª…",
                f"  â€¢ ë¶„ì„ í”„ë ˆì„: {statistics.get('total_frames', 0)}ê°œ",
                f"  â€¢ ì´ ê°ì§€ ê°ì²´: {statistics.get('total_detections', 0)}ê°œ",
                "\nğŸ’¡ í•µì‹¬ ì¸ì‚¬ì´íŠ¸ (ì „ì²´)"
            ]
            
            # ì „ì²´ í•µì‹¬ ì¸ì‚¬ì´íŠ¸ (ìµœëŒ€ 5ê°œ)
            parts.extend([f"  â€¢ {insight}" for insight in key_insights[:5]])
            
            # ì£¼ìš” ì´ë²¤íŠ¸ ì „ì²´ (ìµœëŒ€ 8ê°œ)
            if key_events:
                parts.append("\nâ±ï¸ ì£¼ìš” ì´ë²¤íŠ¸ íƒ€ì„ë¼ì¸:")
                for i, event in enumerate(key_events[:8], 1):
                    timestamp = event.get('timestamp', 0)
                    time_str = f"{int(timestamp//60)}:{int(timestamp%60):02d}"
                    desc = event.get('description', 'ì¥ë©´')[:60]
                    person_cnt = event.get('person_count', 0)
                    activity = event.get('activity_level', 'medium')
                    emoji = "ğŸ”´" if activity == 'high' else "ğŸŸ¡" if activity == 'medium' else "ğŸŸ¢"
                    parts.append(f"  {emoji} {i}. [{time_str}] {desc} ({person_cnt}ëª…)")
            
            # ìƒì„¸ í†µê³„
            parts.append("\nğŸ“Š ìƒì„¸ í†µê³„:")
            parts.append(f"  â€¢ ìµœëŒ€ ë™ì‹œ ì¸ì›: {peak_count}ëª…")
            parts.append(f"  â€¢ í‰ê·  ë™ì‹œ ì¸ì›: {statistics.get('average_person_count', 0):.1f}ëª…")
            
            # í’ˆì§ˆ ì •ë³´
            quality_score = statistics.get('quality_score', 0)
            if quality_score > 0:
                quality_status = "ìš°ìˆ˜" if quality_score > 0.8 else "ì–‘í˜¸" if quality_score > 0.6 else "ë³´í†µ"
                parts.append(f"  â€¢ ì˜ìƒ í’ˆì§ˆ: {quality_status} ({quality_score:.2f}/1.0)")
            
            # ì¥ë©´ ë¶„ì„
            scene_types = statistics.get('scene_types', {})
            if scene_types:
                scene_list = ', '.join([f"{k}({v})" for k, v in list(scene_types.items())[:5]])
                parts.append(f"  â€¢ ì¥ë©´ ìœ í˜•: {scene_list}")
            
            activity_levels = statistics.get('activity_levels', {})
            if activity_levels:
                activity_list = ', '.join([f"{k}({v})" for k, v in activity_levels.items()])
                parts.append(f"  â€¢ í™œë™ ìˆ˜ì¤€: {activity_list}")
            
            lighting_types = statistics.get('lighting_types', {})
            if lighting_types:
                lighting_list = ', '.join([f"{k}({v})" for k, v in lighting_types.items()])
                parts.append(f"  â€¢ ì¡°ëª… ìƒíƒœ: {lighting_list}")
            
            # ë‹¤ì–‘ì„± ì ìˆ˜
            diversity = statistics.get('scene_diversity', 0)
            if diversity > 0:
                parts.append(f"  â€¢ ì¥ë©´ ë‹¤ì–‘ì„±: {diversity:.2f}/1.0")
            
            return "\n".join(parts)
            
        except Exception as e:
            logger.error(f"âŒ ì¢…í•© ìš”ì•½ ìƒì„± ì˜¤ë¥˜: {e}")
            return "ì¢…í•© ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."


class VideoHighlightView(APIView):
    """ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ìë™ ì¶”ì¶œ"""
    permission_classes = [AllowAny]
    
    def post(self, request):
        try:
            video_id = request.data.get('video_id')
            highlight_criteria = request.data.get('criteria', {})
            
            logger.info(f"ğŸ¬ í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ ìš”ì²­: ë¹„ë””ì˜¤={video_id}, ê¸°ì¤€={highlight_criteria}")
            
            if not video_id:
                return Response({'error': 'ë¹„ë””ì˜¤ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.'}, status=400)
            
            try:
                video = Video.objects.get(id=video_id)
            except Video.DoesNotExist:
                return Response({'error': 'ë¹„ë””ì˜¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'}, status=404)
            
            # í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ
            highlights = self._extract_highlights(video, highlight_criteria)
            
            return Response({
                'video_id': video_id,
                'video_name': video.original_name,
                'highlights': highlights,
                'total_highlights': len(highlights),
                'analysis_type': 'video_highlights'
            })
            
        except Exception as e:
            logger.error(f"âŒ í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ ì˜¤ë¥˜: {e}")
            return Response({'error': str(e)}, status=500)
    
    def _extract_highlights(self, video, criteria):
        """í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ"""
        try:
            # ë¶„ì„ ê²°ê³¼ JSON íŒŒì¼ ì½ê¸°
            if not video.analysis_json_path:
                return []
            
            json_path = os.path.join(settings.MEDIA_ROOT, video.analysis_json_path)
            if not os.path.exists(json_path):
                return []
            
            with open(json_path, 'r', encoding='utf-8') as f:
                analysis_data = json.load(f)
            
            frame_results = analysis_data.get('frame_results', [])
            if not frame_results:
                return []
            
            # í”„ë ˆì„ë³„ ì ìˆ˜ ê³„ì‚°
            scored_frames = self._score_frames(frame_results, criteria)
            
            # í•˜ì´ë¼ì´íŠ¸ ìƒì„±
            highlights = self._create_highlights(scored_frames, criteria)
            
            return highlights
            
        except Exception as e:
            logger.error(f"âŒ í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ ì˜¤ë¥˜: {e}")
            return []
    
    def _score_frames(self, frame_results, criteria):
        """í”„ë ˆì„ë³„ ì ìˆ˜ ê³„ì‚°"""
        try:
            scored_frames = []
            
            for frame in frame_results:
                score = 0.0
                
                # ì‚¬ëŒ ìˆ˜ ì ìˆ˜ (ë” ë§ì€ ì‚¬ëŒ = ë” ë†’ì€ ì ìˆ˜)
                person_count = len(frame.get('persons', []))
                if person_count > 0:
                    score += person_count * 0.5
                
                # í’ˆì§ˆ ì ìˆ˜
                quality_score = self._get_quality_score(frame)
                score += quality_score * 0.3
                
                # í™œë™ ìˆ˜ì¤€ ì ìˆ˜
                activity_level = frame.get('scene_attributes', {}).get('activity_level', 'medium')
                if activity_level == 'high':
                    score += 1.0
                elif activity_level == 'medium':
                    score += 0.5
                
                # ì¥ë©´ ë‹¤ì–‘ì„± ì ìˆ˜
                scene_type = frame.get('scene_attributes', {}).get('scene_type', 'unknown')
                if scene_type in ['detailed', 'complex']:
                    score += 0.3
                
                # ì‹ ë¢°ë„ ì ìˆ˜
                avg_confidence = self._get_average_confidence(frame)
                score += avg_confidence * 0.2
                
                scored_frames.append({
                    'frame': frame,
                    'frame_id': frame.get('image_id', 0),
                    'timestamp': frame.get('timestamp', 0),
                    'score': score
                })
            
            # ì ìˆ˜ìˆœìœ¼ë¡œ ì •ë ¬
            scored_frames.sort(key=lambda x: x['score'], reverse=True)
            
            return scored_frames
            
        except Exception as e:
            logger.error(f"âŒ í”„ë ˆì„ ì ìˆ˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    def _get_quality_score(self, frame):
        """í”„ë ˆì„ í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°"""
        try:
            # ê°„ë‹¨í•œ í’ˆì§ˆ ì ìˆ˜ ê³„ì‚° (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš© ê°€ëŠ¥)
            persons = frame.get('persons', [])
            if not persons:
                return 0.0
            
            # í‰ê·  ì‹ ë¢°ë„ ê¸°ë°˜ í’ˆì§ˆ ì ìˆ˜
            confidences = [person.get('confidence', 0) for person in persons]
            avg_confidence = sum(confidences) / len(confidences) if confidences else 0
            
            return avg_confidence
            
        except Exception as e:
            logger.error(f"âŒ í’ˆì§ˆ ì ìˆ˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def _get_average_confidence(self, frame):
        """í‰ê·  ì‹ ë¢°ë„ ê³„ì‚°"""
        try:
            persons = frame.get('persons', [])
            if not persons:
                return 0.0
            
            confidences = [person.get('confidence', 0) for person in persons]
            return sum(confidences) / len(confidences) if confidences else 0
            
        except Exception as e:
            logger.error(f"âŒ í‰ê·  ì‹ ë¢°ë„ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def _create_highlights(self, scored_frames, criteria):
        """í•˜ì´ë¼ì´íŠ¸ ìƒì„±"""
        try:
            highlights = []
            min_score = criteria.get('min_score', 2.0)  # ìµœì†Œ ì ìˆ˜
            max_highlights = criteria.get('max_highlights', 10)  # ìµœëŒ€ í•˜ì´ë¼ì´íŠ¸ ìˆ˜
            
            # ì ìˆ˜ ê¸°ì¤€ í•„í„°ë§
            filtered_frames = [f for f in scored_frames if f['score'] >= min_score]
            
            # ì‹œê°„ ê°„ê²©ì„ ê³ ë ¤í•œ í•˜ì´ë¼ì´íŠ¸ ì„ íƒ
            selected_highlights = []
            last_timestamp = -10  # ìµœì†Œ 10ì´ˆ ê°„ê²©
            
            for frame_data in filtered_frames[:max_highlights * 2]:  # ì—¬ìœ ë¶„ì„ ë‘ê³  ì„ íƒ
                if frame_data['timestamp'] - last_timestamp >= 10:  # 10ì´ˆ ì´ìƒ ê°„ê²©
                    selected_highlights.append(frame_data)
                    last_timestamp = frame_data['timestamp']
                    
                    if len(selected_highlights) >= max_highlights:
                        break
            
            # í•˜ì´ë¼ì´íŠ¸ ì •ë³´ ìƒì„±
            for i, frame_data in enumerate(selected_highlights):
                frame = frame_data['frame']
                highlight = {
                    'id': i + 1,
                    'timestamp': frame_data['timestamp'],
                    'frame_id': frame_data['frame_id'],
                    'score': frame_data['score'],
                    'description': self._generate_highlight_description(frame),
                    'person_count': len(frame.get('persons', [])),
                    'thumbnail_url': f'/api/frame/{frame.get("video_id", 0)}/{frame_data["frame_id"]}/',
                    'significance': self._get_significance_level(frame_data['score']),
                    'scene_type': frame.get('scene_attributes', {}).get('scene_type', 'unknown'),
                    'activity_level': frame.get('scene_attributes', {}).get('activity_level', 'medium')
                }
                highlights.append(highlight)
            
            return highlights
            
        except Exception as e:
            logger.error(f"âŒ í•˜ì´ë¼ì´íŠ¸ ìƒì„± ì˜¤ë¥˜: {e}")
            return []
    
    def _generate_highlight_description(self, frame):
        """í•˜ì´ë¼ì´íŠ¸ ì„¤ëª… ìƒì„±"""
        try:
            persons = frame.get('persons', [])
            person_count = len(persons)
            
            if person_count == 0:
                return "ì£¼ìš” ì¥ë©´"
            elif person_count == 1:
                return "1ëª…ì´ ë“±ì¥í•˜ëŠ” ì¥ë©´"
            elif person_count <= 3:
                return f"{person_count}ëª…ì´ ë“±ì¥í•˜ëŠ” ì¥ë©´"
            else:
                return f"{person_count}ëª…ì´ ë“±ì¥í•˜ëŠ” í™œë°œí•œ ì¥ë©´"
                
        except Exception as e:
            logger.error(f"âŒ í•˜ì´ë¼ì´íŠ¸ ì„¤ëª… ìƒì„± ì˜¤ë¥˜: {e}")
            return "ì£¼ìš” ì¥ë©´"
    
    def _get_significance_level(self, score):
        """ì¤‘ìš”ë„ ë ˆë²¨ ë°˜í™˜"""
        try:
            if score >= 4.0:
                return "ë§¤ìš° ë†’ìŒ"
            elif score >= 3.0:
                return "ë†’ìŒ"
            elif score >= 2.0:
                return "ë³´í†µ"
            else:
                return "ë‚®ìŒ"
                
        except Exception as e:
            logger.error(f"âŒ ì¤‘ìš”ë„ ë ˆë²¨ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return "ë³´í†µ"
    
    def _handle_special_commands(self, message, video_id):
        """íŠ¹ë³„ ëª…ë ¹ì–´ ì²˜ë¦¬ (AIë³„ ê°œë³„ ë‹µë³€ ìƒì„±)"""
        try:
            message_lower = message.lower().strip()
            print(f"ğŸ” íŠ¹ë³„ ëª…ë ¹ì–´ ê²€ì‚¬: '{message_lower}'")
            
            # ì˜ìƒ ìš”ì•½ ëª…ë ¹ì–´
            if any(keyword in message_lower for keyword in ['ìš”ì•½', 'summary', 'ì˜ìƒ ìš”ì•½', 'ì˜ìƒ ìš”ì•½í•´ì¤˜', 'ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ì•Œë ¤ì¤˜', 'ê°„ë‹¨í•œ ìš”ì•½', 'ìƒì„¸í•œ ìš”ì•½']):
                print(f"âœ… ì˜ìƒ ìš”ì•½ ëª…ë ¹ì–´ ê°ì§€: '{message_lower}'")
                return self._handle_ai_generated_response(video_id, 'video_summary', message_lower)
            
            # ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ëª…ë ¹ì–´
            elif any(keyword in message_lower for keyword in ['í•˜ì´ë¼ì´íŠ¸', 'highlight', 'ì£¼ìš” ì¥ë©´', 'ì¤‘ìš”í•œ ì¥ë©´']):
                return self._handle_ai_generated_response(video_id, 'video_highlights', message_lower)
            
            # ì‚¬ëŒ ì°¾ê¸° ëª…ë ¹ì–´
            elif any(keyword in message_lower for keyword in ['ì‚¬ëŒ ì°¾ì•„ì¤˜', 'ì‚¬ëŒ ì°¾ê¸°', 'ì¸ë¬¼ ê²€ìƒ‰', 'ì‚¬ëŒ ê²€ìƒ‰']):
                return self._handle_ai_generated_response(video_id, 'person_search', message_lower)
            
            # ì˜ìƒ ê°„ ê²€ìƒ‰ ëª…ë ¹ì–´
            elif any(keyword in message_lower for keyword in ['ë¹„ê°€ì˜¤ëŠ” ë°¤', 'ë¹„ ì˜¤ëŠ” ë°¤', 'ë°¤ì— ì´¬ì˜', 'ì–´ë‘ìš´ ì˜ìƒ', 'ë¹„ ì˜¤ëŠ” ë‚ ']):
                return self._handle_ai_generated_response(video_id, 'inter_video_search', {'query': message_lower})
            
            # ì˜ìƒ ë‚´ ê²€ìƒ‰ ëª…ë ¹ì–´
            elif any(keyword in message_lower for keyword in ['ì£¼í™©ìƒ‰ ìƒì˜', 'ì£¼í™© ì˜·', 'ì£¼í™©ìƒ‰ ì˜·', 'ì£¼í™© ìƒì˜', 'ì˜¤ë Œì§€ ì˜·']):
                return self._handle_ai_generated_response(video_id, 'intra_video_search', {'query': message_lower})
            
            # ì‹œê°„ëŒ€ë³„ ë¶„ì„ ëª…ë ¹ì–´
            elif any(keyword in message_lower for keyword in ['ì„±ë¹„ ë¶„í¬', 'ì„±ë³„ ë¶„í¬', 'ë‚¨ë…€ ë¹„ìœ¨', 'ì‹œê°„ëŒ€ë³„', '3ì‹œ', '5ì‹œ']):
                time_range = {'start': 180, 'end': 300}  # ê¸°ë³¸ê°’: 3ë¶„-5ë¶„
                return self._handle_ai_generated_response(video_id, 'temporal_analysis', {'time_range': time_range})
            
            return None
            
        except Exception as e:
            logger.error(f"âŒ íŠ¹ë³„ ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            return None
    
    def _handle_ai_generated_response(self, video_id, query_type, query_data=None):
        """AIë³„ ê°œë³„ ë‹µë³€ ìƒì„± ë° í†µí•©"""
        try:
            logger.info(f"ğŸ¤– AI ì‘ë‹µ ìƒì„± ì‹œì‘: video_id={video_id}, query_type={query_type}")
            
            # AI ì‘ë‹µ ìƒì„±
            ai_responses = ai_response_generator.generate_responses(video_id, query_type, query_data)
            
            if not ai_responses:
                return "âŒ AI ì‘ë‹µ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
            
            # ê°œë³„ AI ë‹µë³€ë“¤
            individual_responses = ai_responses.get('individual', {})
            optimal_response = ai_responses.get('optimal', '')
            
            # í†µí•© ì‘ë‹µ ìƒì„±
            response_text = f"## ğŸ¯ AI í†µí•© ë¶„ì„ ê²°ê³¼\n\n{optimal_response}\n\n"
            
            # ê° AIë³„ ë‹µë³€ ì¶”ê°€
            response_text += "## ğŸ“Š ê° AIë³„ ê°œë³„ ë¶„ì„\n\n"
            for ai_name, response in individual_responses.items():
                ai_display_name = {
                    'gpt': 'GPT-4o',
                    'claude': 'Claude-3.5-Sonnet', 
                    'mixtral': 'Mixtral-8x7B',
                    'gemini': 'Gemini-2.5-Flash'
                }.get(ai_name, ai_name.upper())
                
                response_text += f"### {ai_display_name}\n{response}\n\n"
            
            logger.info(f"âœ… AI ì‘ë‹µ ìƒì„± ì™„ë£Œ: {len(response_text)}ì")
            return response_text
            
        except Exception as e:
            logger.error(f"âŒ AI ì‘ë‹µ ìƒì„± ì‹¤íŒ¨: {e}")
            return f"âŒ AI ì‘ë‹µ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"
    
    def _handle_video_summary_command(self, message, video_id):
        """ì˜ìƒ ìš”ì•½ ëª…ë ¹ì–´ ì²˜ë¦¬"""
        try:
            # ìš”ì•½ íƒ€ì… ê²°ì •
            summary_type = 'comprehensive'
            if 'ê°„ë‹¨' in message or 'brief' in message:
                summary_type = 'brief'
            elif 'ìƒì„¸' in message or 'detailed' in message:
                summary_type = 'detailed'
            
            # VideoSummaryView ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ìš”ì•½ ìƒì„±
            summary_view = VideoSummaryView()
            summary_result = summary_view._generate_video_summary(
                Video.objects.get(id=video_id), 
                summary_type
            )
            
            if summary_result and summary_result.get('summary'):
                return f"ğŸ“ **ì˜ìƒ ìš”ì•½** ({summary_type})\n\n{summary_result['summary']}"
            else:
                return "âŒ ì˜ìƒ ìš”ì•½ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜ìƒ ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”."
                
        except Exception as e:
            logger.error(f"âŒ ì˜ìƒ ìš”ì•½ ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            return f"âŒ ì˜ìƒ ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"
    
    def _handle_video_highlight_command(self, message, video_id):
        """ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ëª…ë ¹ì–´ ì²˜ë¦¬"""
        try:
            # í•˜ì´ë¼ì´íŠ¸ ê¸°ì¤€ ì„¤ì •
            criteria = {
                'min_score': 2.0,
                'max_highlights': 5
            }
            
            if 'ë§ì´' in message or 'more' in message:
                criteria['max_highlights'] = 10
            elif 'ì ê²Œ' in message or 'few' in message:
                criteria['max_highlights'] = 3
            
            # VideoHighlightView ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ
            highlight_view = VideoHighlightView()
            highlights = highlight_view._extract_highlights(
                Video.objects.get(id=video_id), 
                criteria
            )
            
            if highlights:
                highlight_text = "ğŸ¬ **ì˜ìƒ í•˜ì´ë¼ì´íŠ¸**\n\n"
                for i, highlight in enumerate(highlights, 1):
                    highlight_text += f"{i}. **{highlight['timestamp']:.1f}ì´ˆ** - {highlight['description']}\n"
                    highlight_text += f"   - ì¤‘ìš”ë„: {highlight['significance']} (ì ìˆ˜: {highlight['score']:.1f})\n"
                    highlight_text += f"   - ì¸ì›: {highlight['person_count']}ëª…, ì¥ë©´: {highlight['scene_type']}\n\n"
                
                return highlight_text
            else:
                return "âŒ í•˜ì´ë¼ì´íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜ìƒ ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”."
                
        except Exception as e:
            logger.error(f"âŒ ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            return f"âŒ ì˜ìƒ í•˜ì´ë¼ì´íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"
